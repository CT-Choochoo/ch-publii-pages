{
    "version": "https://jsonfeed.org/version/1",
    "title": "As One Wants",
    "description": "",
    "home_page_url": "https://ct-choochoo.github.io/ch-publii-pages",
    "feed_url": "https://ct-choochoo.github.io/ch-publii-pages/feed.json",
    "user_comment": "",
    "author": {
        "name": "铁柱"
    },
    "items": [
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/qionglai/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/qionglai/",
            "title": "邛崃特种兵行动",
            "summary": "小玉 ： 这周去乐山，周六一天就够了 小玉 ： 算了，有点热，去青城山？ 我：阔以，走 我：等等 ，青城山昨天出事故了貌似去不了了 -&hellip;",
            "content_html": "<p> </p>\n<blockquote>\n<p class=\"md-end-block md-p md-focus align-left\"><span class=\"md-plain md-expand\"><br>小玉 ： 这周去乐山，周六一天就够了</span></p>\n<p class=\"md-end-block md-p md-focus align-left\"><span class=\"md-plain md-expand\">小玉 ： 算了，有点热，去青城山？</span></p>\n<p class=\"align-right\">我：阔以，走</p>\n<p class=\"align-right\">我：等等 ，青城山昨天出事故了貌似去不了了  - -’</p>\n<figure class=\"post__image post__image--center\"><img decoding=\"async\" loading=\"lazy\"  src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/2023%2F08%2F22%2Fe6bc20361be34c5bc001391ca0eab368.png\" alt=\"\" width=\"1306\" height=\"816\" data-is-external-image=\"true\"></figure>\n<p>emm 。。。。</p>\n</blockquote>\n<p> </p>\n<p>so～   </p>\n<figure class=\"post__image post__image--center\" ><figure class=\"post__image post__image--center\"><img decoding=\"async\" loading=\"lazy\"  src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/IMG_5506.JPG\" alt=\"邛崃我来了\" width=\"4032\" height=\"2268\" sizes=\"(max-width: 48em) 100vw, 100vw\" srcset=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5506-xs.webp 384w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5506-sm.webp 600w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5506-md.webp 768w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5506-lg.webp 1200w\"></figure>\n<figcaption >邛崃我来了</figcaption>\n</figure>\n<p> </p>\n<p>时间 ： 2023-08-19  ～  2023-08-20</p>\n<p>天气 ： 阴转多云 </p>\n<p>穿衣： 夏装 ，短袖短裤</p>\n<p>出行： 成都南站 - 邛崃   34 分钟到达 ，车票 27 元</p>\n<p>住宿：小玉选在了平乐古镇的【邛崃雅阁客栈】还不错</p>\n<p>day 1：</p>\n<p>出发 ：成都 10.06  -  到达 邛崃 10：40 </p>\n<p> </p>\n<figure ><figure class=\"post__image post__image--left\"><img decoding=\"async\" loading=\"lazy\"  src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/IMG_5513.jpeg\" alt=\"\" width=\"4032\" height=\"2268\" sizes=\"(max-width: 48em) 100vw, 100vw\" srcset=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5513-xs.webp 384w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5513-sm.webp 600w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5513-md.webp 768w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5513-lg.webp 1200w\"></figure>\n<figcaption ><br>复刻小红书之首战临邛古镇失利，<br><br>与其说这里是古镇，不如说是各种社会大姐的中介所联盟<br>越挫越勇，下一站号称邛崃太古里的<strong>文脉坊</strong><br>⬇️</figcaption>\n</figure>\n<p> </p>\n<div class=\"gallery-wrapper gallery-wrapper--wide\"><div class=\"gallery\"  data-is-empty=\"false\" data-translation=\"添加图片\" data-columns=\"3\">\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5517.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5517-thumbnail.webp\" alt=\"奶汤面\" width=\"768\" height=\"1365\"></a>\n<figcaption>清淡，叫病号面挺贴切 😂</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5523.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5523-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>文脉坊 - 手持巨款购买喜茶牌水果茶</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5518.JPG\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5518-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>星巴克 挺别致</figcaption>\n</figure>\n</div></div>\n<p>还行，就是那一点钵钵鸡收我 10 块，颇为肉痛🤣</p>\n<p>溜达了一会，打车回平乐古镇了，打车 20 来分钟到住宿的地方，稍微休整下趁着今天天气不错去川西竹海逛逛去。</p>\n<p>住宿环境如下： ⬇️</p>\n<div class=\"gallery-wrapper gallery-wrapper--wide\"><div class=\"gallery\"  data-is-empty=\"false\" data-translation=\"添加图片\" data-columns=\"3\">\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5526.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5526-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>房间</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5527.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5527-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>廊道1</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5633.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5633-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>廊道2</figcaption>\n</figure>\n</div></div>\n<p>平乐古镇到川西竹海有一段 2km 左右的路程，行程从古镇街道经过一座拱桥，过桥后顺着河岸继续走，河边有很多茶馆，赤着脚坐在竹编的椅子上，上面热茶入口，下方清凉的河水趟过脚趾。。。都是我想的 ，时间紧任务重，我们要趁着下午这会时间攻克⬇️</p>\n<h5 class=\"align-center\"><strong>川西竹海</strong></h5>\n<p>川西竹海 3A 级景区，毗邻平乐古镇，票价 57 元，还有滑道，小火车，玻璃栈道，玻璃桥等游乐设施；<br>景区内路线大致是套索状，（下方会贴出徒步路线记录图）， 景区内堪称中国湿度天花板，景区的加湿器开的太过强劲，估计没有一个人能干爽的走出川西竹海，还有台阶路面湿滑去的老铁一定小心，小玉在此摔了个大屁蹲。。。</p>\n<div class=\"gallery-wrapper gallery-wrapper--wide\"><div class=\"gallery\"  data-is-empty=\"false\" data-translation=\"添加图片\" data-columns=\"3\">\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5534.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5534-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>平乐古镇-川西竹海路旁</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5545.jpeg\" data-size=\"4032x3024\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5545-thumbnail.webp\" alt=\"\" width=\"768\" height=\"576\"></a>\n<figcaption>批发小葫芦</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5571.jpeg\" data-size=\"8064x4536\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5571-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>撑腰木</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5553.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5553-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>这里很美，手机拍出来包看</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5582.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5582-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>满分100 考 50 也很棒</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5591.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5591-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>川西竹海</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5593.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5593-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>这是嘛</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5610.jpeg\" data-size=\"1629x2896\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5610-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>玻璃桥</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5613.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5613-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>叛逆少年</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5718.PNG\" data-size=\"1290x2796\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5718-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1665\"></a>\n<figcaption>没多远，但是山路崎岖，还是要穿双舒服的鞋</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5717.PNG\" data-size=\"1290x2796\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5717-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1665\"></a>\n<figcaption>徒步记录</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5629.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5629-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>古镇第一鱼，报吃还诈骗</figcaption>\n</figure>\n</div></div>\n<p>川西竹海归来，客栈休息了一下，晚上有点饿了，顺便还惦记着红汤羊肉，浅吃了一点</p>\n<div class=\"gallery-wrapper gallery-wrapper--wide\"><div class=\"gallery\"  data-is-empty=\"false\" data-translation=\"添加图片\" data-columns=\"2\">\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/870511692676326_.pic.jpg\" data-size=\"1330x2364\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/870511692676326_.pic-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>小玉的冰粉，不予置评</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5640.jpeg\" data-size=\"4536x8064\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/IMG_5640-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>清补凉很好吃 10 分！</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/870551692676379_.pic.jpg\" data-size=\"1330x2364\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/gallery/870551692676379_.pic-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>红汤羊肉也很不错，25 一份，分量足，味道棒</figcaption>\n</figure>\n</div></div>\n<p>在客栈讨论第二天是去天台山还是去雅安碧峰峡，崇州 xx 古镇的我们，还不知道第二天会下大半天的雨，改变了全部计划。</p>\n<figure ><figure class=\"post__image post__image--right\"><img decoding=\"async\" loading=\"lazy\"  src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/IMG_5651.jpeg\" alt=\"\" width=\"8064\" height=\"4536\" sizes=\"(max-width: 48em) 100vw, 100vw\" srcset=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5651-xs.webp 384w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5651-sm.webp 600w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5651-md.webp 768w ,https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/responsive/IMG_5651-lg.webp 1200w\"></figure>\n<figcaption ><strong>第二天一大早起来，</strong><br><strong>下雨 </strong><br><strong>⬇️</strong><br><strong>打车</strong><br><strong>⬇️</strong><br><strong>改签回🚄成都。🤪</strong></figcaption>\n</figure>\n<p>邛崃还成，下次还来，为红汤羊肉，为青山<span style=\"text-decoration: line-through;\">绿</span>黄水。</p>",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/38/IMG_5545.jpeg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "real",
                   "outing"
            ],
            "date_published": "2023-08-22T12:14:51+08:00",
            "date_modified": "2023-08-22T16:22:11+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/applescript-ji-chu/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/applescript-ji-chu/",
            "title": "AppleScript 基础",
            "summary": "本章介绍本指南其余部分所涵盖的术语和规则所依据的基本概念。 文档来源 “脚本编辑器”应用程序位于 中 /Applications/Utilities 。它提供了编辑、编译和执行脚本、显示应用程序脚本术语以及以各种格式（如编译脚本、应用程序和纯文本）保存脚本的功能。 脚本编辑器可以显示执行 AppleScript 脚本的结果，并且可以显示在脚本执行期间发送的 Apple&hellip;",
            "content_html": "<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain md-expand\">本章介绍本指南其余部分所涵盖的术语和规则所依据的基本概念。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html#//apple_ref/doc/uid/TP40000983-CH218-SW2\"><span class=\"md-plain\">文档来源</span></a></span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"> </p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">1. 脚本编辑器</span></h2>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">“脚本编辑器”应用程序位于 中 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/Applications/Utilities</code></span><span class=\"md-plain\"> 。它提供了编辑、编译和执行脚本、显示应用程序脚本术语以及以各种格式（如编译脚本、应用程序和纯文本）保存脚本的功能。</span></p>\n</li>\n<li class=\"md-list-item md-focus-container\">\n<p class=\"md-end-block md-p md-focus\"><span class=\"md-plain md-expand\">脚本编辑器可以显示执行 AppleScript 脚本的结果，并且可以显示在脚本执行期间发送的 Apple 事件的日志。在“脚本编辑器首选项”中，您还可以选择保留最近结果或事件日志的历史记录。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本编辑器对各种类型的脚本文本具有文本格式化首选项，例如语言关键字、注释等。您还可以打开或关闭脚本助手(Script Assistant)，这是一种代码补全工具，可以在您输入脚本时建议和填写脚本术语。此外，脚本编辑器提供了一个上下文菜单，可以插入许多类型的样板脚本语句，例如条件语句、注释和错误处理程序。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">字典是可脚本应用程序的一部分，用于指定它所理解的脚本术语。你可以选择File </span><span class=\"md-entity\" style=\"box-sizing: border-box;\" data-content=\"&gt;\">&gt;</span><span class=\"md-plain\">在脚本编辑器中打开字典，在计算机上显示可脚本化应用程序或脚本添加的字典。或者，您可以将应用程序图标拖动到脚本编辑器图标以显示其字典(如果它有的话)。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">要显示一个列表，其中只包含由macOS提供的可脚本应用程序和脚本添加，选择Window </span><span class=\"md-entity\" style=\"box-sizing: border-box;\" data-content=\"&gt;\">&gt;</span><span class=\"md-plain\">图书馆。双击列表中的项以显示其字典。图2-1展示了OS X v10.5中Finder应用程序的字典。这个字典被标记为\" Finder.sdef \"。sdef格式和其他术语格式在applecript概述中的</span><span class=\"md-pair-s \"><em><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i\"><span class=\"md-plain\">AppleScript Overview</span></a></span></em></span><span class=\"md-plain\">一节中有描述。</span></p>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-image md-img-loaded\" data-src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/2023%2F08%2F21%2F184e562a09fdf34f7983d8ff1cadaee8.png\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/2023%2F08%2F21%2F184e562a09fdf34f7983d8ff1cadaee8.png\" alt=\"image-20230820171806291\" data-is-external-image=\"true\"></span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h2 class=\"md-end-block md-heading\"><span class=\"md-plain\">2. AppleScript and Objects - AppleScript 和对象</span></h2>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 是一种面向对象的语言。在编写、编译和执行脚本时，你所处理的一切都是对象。对象是类定义的实例化，可以包含属性和操作。AppleScript 为你最常使用的对象定义了类，首先是顶级 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_classes.html#//apple_ref/doc/uid/TP40000983-CH1g-SW5\"><span class=\"md-plain\">script</span></a></span><span class=\"md-plain\"> 对象，也就是你正在使用的整个脚本。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象内，您可以与其他对象一起工作，包括</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 为布尔值、脚本、文本、数字和其他用于脚本的对象定义了类；有关完整列表，请参阅</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_classes.html#//apple_ref/doc/uid/TP40000983-CH1g-246384\"><span class=\"md-plain\">Class Reference</span></a></span><span class=\"md-plain\">。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">macOS 的可编写脚本部分和随附的应用程序，如 Finder、System Events 和 Database Events（位于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/System/Library/CoreServices</code></span><span class=\"md-plain\"> ），定义了许多有用的类。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">第三方脚本应用程序定义了支持各种功能的类。</span></p>\n</li>\n</ul>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.1 What Is in a Script Object - 脚本类包含哪些内容</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在脚本编辑器的脚本窗口中输入 AppleScript 语句时，您是在顶级 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象中工作。所有 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象定义都遵循相同的语法，只是顶级 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象没有标记开始和结束的语句。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">script 包含以下内容：</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">属性定义 （可选） 变量</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">明确 run 处理程序（可选） </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 处理程序包含运行脚本时 AppleScript 执行的语句。(更多信息，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-SW15\"><span class=\"md-plain\">run Handlers</span></a></span><span class=\"md-plain\">）</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">隐式 run 处理程序（可选） 隐式 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 处理程序包括在任何包含的处理程序或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象之外的任何语句。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">附加处理程序（可选）：处理程序相当于子程序。(详情请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-CJBIDBJH\"><span class=\"md-plain\">About Handlers</span></a></span><span class=\"md-plain\">）。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">附加 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象（可选）：</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象可以包含嵌套的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象，每个嵌套对象的定义都与顶层的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象相同，只是嵌套的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象在括号中用语句标明其开始和结束。(详情请参阅脚本对象）。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面是一个简单脚本的示例，其中包含一个属性、一个处理程序、一个嵌套的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象和一个隐式 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 处理程序，处理程序包含两条语句：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">property</span> <span class=\"cm-keyword\">defaultClientName</span> <span class=\"cm-keyword\">:</span> <span class=\"cm-string\">\"Mary Smith\"</span></span><br>  <br> <span role=\"presentation\"><span class=\"cm-keyword\">on</span> <span class=\"cm-keyword\">greetClient</span>(<span class=\"cm-keyword\">nameOfClient</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">display</span> <span class=\"cm-keyword\">dialog</span> (<span class=\"cm-string\">\"Hello \"</span> <span class=\"cm-keyword\">&amp;</span> <span class=\"cm-keyword\">nameOfClient</span> <span class=\"cm-keyword\">&amp;</span> <span class=\"cm-string\">\"!\"</span>)</span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">greetClient</span></span><br>  <br> <span role=\"presentation\"><span class=\"cm-keyword\">script</span> <span class=\"cm-keyword\">testGreet</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">greetClient</span>(<span class=\"cm-keyword\">defaultClientName</span>)</span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">script</span></span><br>  <br> <span role=\"presentation\"><span class=\"cm-keyword\">run</span> <span class=\"cm-keyword\">testGreet</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"Hello Mary Smith!\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">greetClient</span>(<span class=\"cm-string\">\"Joe Jones\"</span>) <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"Hello Joe Jones!\"</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 处理程序的第一条语句是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>run testGreet</code></span><span class=\"md-plain\"> ，运行嵌套的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>testGreet</code></span><span class=\"md-plain\"> 。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象调用处理程序 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>greetClient()</code></span><span class=\"md-plain\"> ，传递属性 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>defaultClientName</code></span><span class=\"md-plain\"> 。处理程序会显示一个对话框，问候默认客户端Mary Smith。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 处理程序中的第二条语句直接调用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>greetClient()</code></span><span class=\"md-plain\"> ，传递字符串 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"Joe Jones\"</code></span><span class=\"md-plain\"> 。</span></p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">从Java语言的角度来看，AppleScript的脚本对象可以与Java中的类进行比较。以下是AppleScript脚本对象的各个部分与Java的对应关系：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Property definitions (optional)</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这与Java中的类变量或属性相似。它们是用来存储数据的容器。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">public</span> <span class=\"cm-keyword\">class</span> <span class=\"cm-def\">MyClass</span> {</span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">private</span> <span class=\"cm-variable-3\">int</span> <span class=\"cm-variable\">myProperty</span>;</span><br> <span role=\"presentation\">}</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">An explicit run handler (optional)</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这可以看作是Java类中的一个特定方法，当该类被执行时会调用这个方法。在Java中，这类似于</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>main</code></span><span class=\"md-plain\">方法。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">public</span> <span class=\"cm-keyword\">static</span> <span class=\"cm-variable-3\">void</span> <span class=\"cm-def\">main</span>(<span class=\"cm-variable-3\">String</span>[] <span class=\"cm-variable\">args</span>) {</span><br> <span role=\"presentation\">    <span class=\"cm-comment\">// code to be executed</span></span><br> <span role=\"presentation\">}</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">An implicit run handler (optional)</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这是类中不在任何方法内的代码块。但在Java中，所有的代码都需要放在方法内，所以没有直接的对应。但可以将其看作是静态代码块或初始化块。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">static</span> {</span><br> <span role=\"presentation\">    <span class=\"cm-comment\">// static initialization code</span></span><br> <span role=\"presentation\">}</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Additional handlers (optional)</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这与Java中的方法相似。它们是执行特定功能的代码块。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">public</span> <span class=\"cm-variable-3\">void</span> <span class=\"cm-def\">myMethod</span>() {</span><br> <span role=\"presentation\">    <span class=\"cm-comment\">// code for the method</span></span><br> <span role=\"presentation\">}</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Additional script objects (optional)</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这与Java中的内部类或嵌套类相似。一个类可以包含其他类。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">public</span> <span class=\"cm-keyword\">class</span> <span class=\"cm-def\">OuterClass</span> {</span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">public</span> <span class=\"cm-keyword\">class</span> <span class=\"cm-def\">InnerClass</span> {</span><br> <span role=\"presentation\">        <span class=\"cm-comment\">// inner class code</span></span><br> <span role=\"presentation\">    }</span><br> <span role=\"presentation\">}</span></pre>\n</li>\n</ol>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">总的来说，AppleScript的脚本对象与Java的类有很多相似之处，都包含属性、方法和可能的嵌套结构。但AppleScript的运行处理器（run handler）是其独特的特点，而Java则通过特定的方法（如</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>main</code></span><span class=\"md-plain\">方法）来执行代码。</span></p>\n</blockquote>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.2 Properties - 属性</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象的属性是具有单一值和标签的特性，如窗口的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name</code></span><span class=\"md-plain\"> 属性或日期的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>month</code></span><span class=\"md-plain\"> 属性。任何 AppleScript 类的定义都包括其每个属性的名称和类。在一个类中，属性名称必须是唯一的。属性值可以是读/写或只读。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">例如，AppleScript </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>date</code></span><span class=\"md-plain\"> 类定义了读/写和只读属性。这些属性包括 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>weekday</code></span><span class=\"md-plain\"> 属性（只读）和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>month</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>day</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>year</code></span><span class=\"md-plain\"> 属性（读/写）。这是因为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>weekday</code></span><span class=\"md-plain\"> 属性的值取决于其他属性--你不能将任意工作日设置为实际日期。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">属性的类可以是简单类（如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>boolean</code></span><span class=\"md-plain\"> 或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\"> ）、复合类（如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>point</code></span><span class=\"md-plain\"> 类（由两个整数组成））或更复杂的类。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">大多数类只支持预定义属性。不过，对于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 类，AppleScript 允许你定义其他属性。有关如何定义的信息，请参阅</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_variables.html#//apple_ref/doc/uid/TP40000983-CH223-SW2\"><span class=\"md-plain\">Defining Properties</span></a></span><span class=\"md-plain\">。您还可以为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>record</code></span><span class=\"md-plain\"> 对象定义属性。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.3 Elements - 元素</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">元素是包含在另一个对象中的对象。任何 AppleScript 类的定义都包括其可包含的元素类型。一个对象通常可以包含零个或多个元素。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于给定的元素类型，一个对象可以包含很多元素，也可以不包含任何元素，而且它所包含的元素数量可能会随着时间的推移而改变。例如，一个 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> 对象可能不包含任何项目（可以是一个空列表）。之后，同一个列表可能包含许多项目。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">能否在对象中添加元素或从对象中删除元素取决于类和元素。例如， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 对象是不可变的--对象创建后就不能添加或删除文本。对于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> 对象，您不能删除项目，但可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>set</code></span><span class=\"md-plain\"> 命令在开头或结尾添加项目：</span></p>\n<figure class=\"md-table-fig table-figure\">\n<table class=\"md-table\">\n<thead>\n<tr class=\"md-end-block\">\n<th><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>set myList to {1, \"what\", 3} --result: {1, \"what\", 3}</code></span></span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>set beginning of myList to 0</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>set end of myList to \"four\"</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>myList --result: {0, 1, \"what\", 3, \"four\"}</code></span></span></td>\n</tr>\n</tbody>\n</table>\n</figure>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">从Java的角度来看，AppleScript中的元素（element）概念与Java中的集合或数组中的元素有些相似。以下是AppleScript中的元素与Java的对应关系：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">Element</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，集合（如</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ArrayList</code></span><span class=\"md-plain\">、</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>HashSet</code></span><span class=\"md-plain\">等）或数组中的项可以被视为元素。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable-3\">String</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-variable\">myList</span> <span class=\"cm-operator\">=</span> <span class=\"cm-keyword\">new</span> <span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;&gt;</span>();</span><br> <span role=\"presentation\"><span class=\"cm-variable\">myList</span>.<span class=\"cm-variable\">add</span>(<span class=\"cm-string\">\"item1\"</span>);</span><br> <span role=\"presentation\"><span class=\"cm-variable\">myList</span>.<span class=\"cm-variable\">add</span>(<span class=\"cm-string\">\"item2\"</span>);</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">Definition for any AppleScript class includes the element types it can contain</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，泛型可以限制集合中可以包含的元素类型。例如，</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ArrayList&lt;String&gt;</code></span><span class=\"md-plain\">只能包含字符串。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">An object can typically contain zero or more of each of its elements</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 一个Java集合可以为空，或者可以包含多个元素。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable-3\">String</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-variable\">emptyList</span> <span class=\"cm-operator\">=</span> <span class=\"cm-keyword\">new</span> <span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;&gt;</span>();</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">For a given element type, an object can contain many elements or none</span></strong></span><span class=\"md-plain\">:</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这与Java集合的行为相似。例如，一个</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ArrayList</code></span><span class=\"md-plain\">可以为空，或者可以包含多个元素。</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Whether you can add elements to or remove elements from an object depends on the class and the element</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，某些集合类型是不可变的，例如</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Arrays.asList()</code></span><span class=\"md-plain\">返回的列表。但大多数集合，如</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ArrayList</code></span><span class=\"md-plain\">，允许添加和删除元素。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;</span><span class=\"cm-variable-3\">String</span><span class=\"cm-operator\">&gt;</span> <span class=\"cm-variable\">myList</span> <span class=\"cm-operator\">=</span> <span class=\"cm-keyword\">new</span> <span class=\"cm-variable\">ArrayList</span><span class=\"cm-operator\">&lt;&gt;</span>();</span><br> <span role=\"presentation\"><span class=\"cm-variable\">myList</span>.<span class=\"cm-variable\">add</span>(<span class=\"cm-string\">\"item1\"</span>);  <span class=\"cm-comment\">// 添加元素</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">myList</span>.<span class=\"cm-variable\">remove</span>(<span class=\"cm-string\">\"item1\"</span>);  <span class=\"cm-comment\">// 删除元素</span></span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">For a list object, you cannot remove items, but you can use the set command to add an item to the beginning or end</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java的</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ArrayList</code></span><span class=\"md-plain\">中，你可以使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>add(int index, E element)</code></span><span class=\"md-plain\">方法在指定位置添加元素，或使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>remove(int index)</code></span><span class=\"md-plain\">方法删除指定位置的元素。</span></p>\n<pre class=\"md-fences mock-cm md-end-block md-fences-with-lineno\" lang=\"java\" spellcheck=\"false\">ArrayList&lt;String&gt; myList = new ArrayList&lt;&gt;();<br>myList.add(0, \"itemAtBeginning\");  // 在开始位置添加元素<br>myList.add(myList.size(), \"itemAtEnd\");  // 在末尾添加元素</pre>\n</li>\n</ol>\n</blockquote>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.4 Object Specifiers - 对象标志符</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象指定符指定了查找另一个对象所需的信息，即该对象所包含的对象。对象指定符可以指应用程序对象（如窗口或文件），也可以指 AppleScript 对象（如列表中的项目或记录中的属性）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">只有在运行脚本时，而不是在编译脚本时，对象指定符才会被完全评估（或解析）。脚本可以包含一个有效的对象指定符（如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>third document of application \"TextEdit\"</code></span><span class=\"md-plain\"> ），但在执行脚本时会导致错误（例如，因为打开的文档可能少于三个）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">应用程序在响应命令时通常会返回对象指定符。例如，如果你要求 Finder 提供一个窗口，它会返回指定脚本所要求的窗口对象（如果存在）的信息。对象指定符中的顶层容器通常是应用程序本身。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">每次脚本使用描述对象或属性路径的短语时，都会创建一个对象指定符，例如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name of window 1 of application \"Finder\"</code></span><span class=\"md-plain\"> 。当您使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>a reference to</code></span><span class=\"md-plain\"> 操作符时，它会创建一个包裹对象指定符的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>reference</code></span><span class=\"md-plain\"> 对象。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象指定符与其所指对象之间的区别，就像建筑物地址与建筑物本身之间的区别一样。地址是一系列单词和数字，例如 \"2121 Oak Street, San Francisco, CA\"，它标识了一个地点（在一条街道上、一个城市里、一个州里）。它有别于建筑物本身。如果该地点的建筑被拆除，取而代之的是一栋新建筑，地址也不会改变。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">从Java的角度来看，AppleScript中的对象说明符（object specifier）与Java中的引用有些相似。以下是AppleScript中的对象说明符与Java的对应关系：</span></p>\n<ol class=\"ol-list\" start=\"\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Object Specifier</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，当你创建一个对象并将其赋值给一个变量时，这个变量实际上存储的是对象的引用，而不是对象本身。这个引用可以被视为一个指向对象的“指针”或“地址”。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">Window</span> <span class=\"cm-variable\">mainWindow</span> <span class=\"cm-operator\">=</span> <span class=\"cm-keyword\">new</span> <span class=\"cm-variable\">Window</span>(<span class=\"cm-string\">\"Main Window\"</span>);</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在上面的例子中，</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>mainWindow</code></span><span class=\"md-plain\">是一个指向</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Window</code></span><span class=\"md-plain\">对象的引用。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">An object specifier is fully evaluated (or resolved) only when a script is run, not when it is compiled</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，对象的实例化（即</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>new</code></span><span class=\"md-plain\">操作）发生在运行时。但类型检查和编译时错误检查是在编译时完成的。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Applications typically return object specifiers in response to commands</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 当你调用一个方法并且它返回一个对象，实际上返回的是该对象的引用。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">public</span> <span class=\"cm-variable\">Window</span> <span class=\"cm-def\">getWindow</span>() {</span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">return</span> <span class=\"cm-keyword\">new</span> <span class=\"cm-variable\">Window</span>(<span class=\"cm-string\">\"Returned Window\"</span>);</span><br> <span role=\"presentation\">}</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">The top-level container in an object specifier is typically the application itself</span></strong></span><span class=\"md-plain\">:</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，顶级容器可以是主类或主应用程序，它包含和管理其他对象。</span></p>\n</li>\n</ul>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">You create an object specifier every time your script uses a phrase that describes the path to an object or property</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 在Java中，你可以通过对象引用来访问其属性或方法。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable-3\">String</span> <span class=\"cm-variable\">title</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">mainWindow</span>.<span class=\"cm-variable\">getTitle</span>();</span></pre>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">The difference between an object specifier and the object it refers to</span></strong></span><span class=\"md-plain\">:</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Java</span></strong></span><span class=\"md-plain\">: 这与Java中的引用与实际对象之间的区别相似。引用是一个指向对象的指针，而实际的对象存在于内存的某个位置。你可以有多个引用指向同一个对象，但对象本身只有一个。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"java\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">Window</span> <span class=\"cm-variable\">anotherReference</span> <span class=\"cm-operator\">=</span> <span class=\"cm-variable\">mainWindow</span>;</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在上面的例子中，</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>mainWindow</code></span><span class=\"md-plain\">和</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>anotherReference</code></span><span class=\"md-plain\">都指向同一个</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Window</code></span><span class=\"md-plain\">对象。</span></p>\n</li>\n</ol>\n</blockquote>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.4.1 What Is in an Object Specifier 对象说明符包含哪些内容</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对象指定符描述了一个对象的类型、位置以及如何将该对象与该位置上相同类型的其他对象区分开来。这三种类型的信息--类型（或类）、位置（或容器）和区别信息（或引用形式）--允许你指定任何对象。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在下面的示例中，对象的类是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>paragraph</code></span><span class=\"md-plain\"> 。容器是短语 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>of document 1</code></span><span class=\"md-plain\"> 。由于该短语位于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句中，因此 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句提供了顶层容器 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>of application \"TextEdit\"</code></span><span class=\"md-plain\"> 。区别信息（引用形式）是类 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>paragraph</code></span><span class=\"md-plain\"> 和索引值 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>1</code></span><span class=\"md-plain\"> 的组合，它们共同表示第一段。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">paragraph</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">document</span> <span class=\"cm-number\">1</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注：如果查看 TextEdit 应用程序的字典，您可能会认为该脚本应该写 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>paragraph 1 of text of document 1</code></span><span class=\"md-plain\"> 。不过，如果意思不明确，有些应用程序允许脚本编写者从对象指定符中省略容器，从而使脚本编写者的工作更加轻松。TextEdit 就使用了这一功能，为文档中的文本提供了一个隐式指定的子容器。也就是说，如果一个对象指定符标识了一个包含在文档文本中的对象（如单词或段落），TextEdit 就会自动提供该对象指定符的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>of text</code></span><span class=\"md-plain\"> 部分。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">除了索引引用表单外，您还可以通过名称、范围、ID 和</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_reference_forms.html#//apple_ref/doc/uid/TP40000983-CH4g-120522\"><span class=\"md-plain\">Reference Forms</span></a></span><span class=\"md-plain\">中描述的其他表单来指定容器中的对象。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.4.2 Containers 容器</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">容器是包含一个或多个对象或属性的对象。在对象说明符中，容器指定了查找对象或属性的位置。要指定容器，请使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>of</code></span><span class=\"md-plain\"> 或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>in</code></span><span class=\"md-plain\"> ，如下面的语句（来自 Finder </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 块）：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">folder \"Applications\" of startup disk</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">容器可以是一个对象，也可以是一系列对象，从最内层到最外层依次排列，如下图所示：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">folder</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">disk</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">也可以使用属格形式 ( </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>'s</code></span><span class=\"md-plain\"> ) 来指定容器。在下面的示例中，最内层的容器是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>first window</code></span><span class=\"md-plain\"> ，其中包含的对象是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name</code></span><span class=\"md-plain\"> 属性：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">window</span><span class=\"cm-string\">'s name</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在本例中， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句 ( </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"TextEdit\"</code></span><span class=\"md-plain\"> ) 的目标是对象指定符的外部容器。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.4.3 Absolute and Relative Object Specifiers 绝对和相对对象指定符</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">绝对对象指定符有足够的信息来唯一地识别一个或多个对象。它可以在脚本的任何地方明确使用。要使对应用程序对象的引用具有绝对性，其最外层的容器必须是应用程序本身，如下所示：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">version</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"10.5.1\"</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">与此相反，相对对象指定符没有指定足够的信息来唯一地识别一个或多个对象，例如</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">disk</span> <span class=\"cm-number\">2</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当 AppleScript 在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句中遇到相对对象指定符时，它会尝试使用语句指定的默认目标来完成对象指定符。虽然一般情况下并不需要，但可以使用关键字 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>it</code></span><span class=\"md-plain\"> 来显式地指定这个隐式目标，详情请参阅 it 和 me 关键字。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果没有指定其他对象， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句的默认目标是接收命令的对象。例如，下面的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句告诉 Finder 使用前面的相对对象指定符获取一个名称。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">disk</span> <span class=\"cm-number\">2</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当 AppleScript 在任何 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句之外遇到相对对象指定符时，它会尝试通过查找</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html#//apple_ref/doc/uid/TP40000983-CH207-SW5\"><span class=\"md-plain\">Inheritance in Script Objects</span></a></span><span class=\"md-plain\">描述的继承链来完成对象指定符。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.4.4 Object Specifiers in Reference Object - 引用对象中的对象指定符</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>a reference to</code></span><span class=\"md-plain\"> 运算符创建 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>reference</code></span><span class=\"md-plain\"> 对象时，其中包含一个对象指定符。例如</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">docRef</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">a</span> <span class=\"cm-keyword\">reference</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">the</span> <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">document</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--result:</span> <span class=\"cm-keyword\">document</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">        <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">an</span> <span class=\"cm-keyword\">object</span> <span class=\"cm-keyword\">specifier</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">docRef</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"New Report.rtf\"</span></span><br> <span role=\"presentation\">        <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">the</span> <span class=\"cm-keyword\">specified</span> <span class=\"cm-keyword\">object</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在本脚本中，变量 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>docRef</code></span><span class=\"md-plain\"> 是一个引用，其对象指定符指向应用程序 TextEdit 的第一个文档--在本例中，该文档恰好被命名为 \"New Report.rtf\"。不过， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>docRef</code></span><span class=\"md-plain\"> 所指向的对象是可以改变的。如果打开第二个名为 \"Second Report.rtf \"的 TextEdit 文档，使其窗口位于前一个文档的前面，然后再次运行此脚本，它将返回现在最前面文档的名称 \"Second Report.rtf\"。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以使用更具体的对象指定符来创建引用：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">docRef</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">a</span> <span class=\"cm-keyword\">reference</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">document</span> <span class=\"cm-string\">\"New Report.rtf\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--result:</span> <span class=\"cm-keyword\">document</span> <span class=\"cm-string\">\"New Report.rtf\"</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">docRef</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"New Report.rtf\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果您在打开第二个文档后运行此脚本，它仍会返回原始文档的名称 \"New Report.rtf\"（如果该文档存在）。</span> <span class=\"md-plain\">使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>a reference to</code></span><span class=\"md-plain\"> 操作符创建 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>reference</code></span><span class=\"md-plain\"> 对象后，可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>contents</code></span><span class=\"md-plain\"> 属性获取其引用对象的值。也就是说，使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>contents</code></span><span class=\"md-plain\"> 属性会对引用的对象指定符进行求值。例如，在下面的脚本中，变量 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>myWindow</code></span><span class=\"md-plain\"> 的内容就是窗口引用本身。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">myWindow</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">a</span> <span class=\"cm-keyword\">ref</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-string\">\"Q1.rtf\"</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">myWindow</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">result:</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-string\">\"Q1.rtf\"</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span> (<span class=\"cm-keyword\">object</span> <span class=\"cm-keyword\">specifier</span>)</span><br> <span role=\"presentation\"><span class=\"cm-keyword\">contents</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">myWindow</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--result:</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-keyword\">id</span> <span class=\"cm-number\">283</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span> (<span class=\"cm-keyword\">an</span> <span class=\"cm-keyword\">evaluated</span> <span class=\"cm-keyword\">window</span>)</span><br> <span role=\"presentation\"><span class=\"cm-keyword\">get</span> <span class=\"cm-keyword\">myWindow</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">result:</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-string\">\"Q1.rtf\"</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span> (<span class=\"cm-keyword\">object</span> <span class=\"cm-keyword\">specifier</span>)</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">请注意， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>get</code></span><span class=\"md-plain\"> 命令的结果是返回引用的对象指定符，而不是将指定符解析为它所指定的对象。</span> <span class=\"md-plain\">如果可以，AppleScript 将隐式取消引用对象（不使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>contents</code></span><span class=\"md-plain\"> 属性），如下例所示：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">myWindow</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">a</span> <span class=\"cm-keyword\">ref</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">myWindow</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"Q1.rtf\"</span> (<span class=\"cm-keyword\">if</span> <span class=\"cm-keyword\">that</span> <span class=\"cm-keyword\">is</span> <span class=\"cm-keyword\">the</span> <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">window</span><span class=\"cm-string\">'s name)</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有关信息，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_classes.html#//apple_ref/doc/uid/TP40000983-CH1g-BBCDJJDE\"><span class=\"md-plain\">reference</span></a></span><span class=\"md-plain\"> 类的讨论部分。</span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.5 Coercion (Object Conversion) - 强制（对象转换）</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">强制（也称为对象转换）是将对象从一个类转换为另一个类的过程。在上述两种情况下，AppleScript 都会将对象转换为不同的类：</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">作为对as运算符的响应我</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当对象的类别与特定命令或操作的预期类别不同时，系统会自动转换</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">并非所有类都可以强制为所有其他类类型。表 2-1 总结了 AppleScript 对常用类支持的强制。有关每种强制的详细信息，请参阅《</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_classes.html#//apple_ref/doc/uid/TP40000983-CH1g-246384\"><span class=\"md-plain\">Class Reference</span></a></span><span class=\"md-plain\">》中相应的类定义。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 提供了许多强制机制，这些机制可以是语言的内置部分，也可以通过标准附加脚本附加功能提供。您可以在脚本中的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 代码块之外使用这些强制。不过，应用程序类类型的强制可能取决于应用程序，因此需要一个针对应用程序的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 代码块。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>as</code></span><span class=\"md-plain\"> 操作符指定一个或一组特定的强制。例如，下面的语句将整数 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>2</code></span><span class=\"md-plain\"> 强制转换为文本 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"2\"</code></span><span class=\"md-plain\"> ，然后存储到变量 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>myText</code></span><span class=\"md-plain\"> 中：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">set myText to 2 as text</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果您提供了错误类别的命令参数或操作数，AppleScript 会尽可能自动将操作数或参数强制转换为预期类别。如果无法进行转换，AppleScript 将报错。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">将 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 字符串强制转换为类 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>number</code></span><span class=\"md-plain\"> 或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span><span class=\"md-plain\"> 的值时，AppleScript 会使用 \"国际首选项 \"中 \"格式 \"窗格的当前 \"数字 \"设置来决定在字符串中使用哪些分隔符。将字符串强制转换为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>date</code></span><span class=\"md-plain\"> 类的值时，AppleScript 会使用 \"格式 \"窗格中的当前 \"日期 \"设置。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<figure class=\"md-table-fig table-figure\">\n<table class=\"md-table\">\n<thead>\n<tr class=\"md-end-block\">\n<th><span class=\"td-span\"><span class=\"md-plain\">类别转换</span></span></th>\n<th><span class=\"td-span\"><span class=\"md-plain\">转换类</span></span></th>\n<th><span class=\"td-span\"><span class=\"md-plain\">说明</span></span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item)</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>application</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item)</span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">这既是一个 AppleScript 类，也是一个应用程序类。</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>boolean</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer``list</code></span><span class=\"md-plain\"> (single-item)</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>class</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>constant</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>date</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real text</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">将</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\">强制转换为</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>number</code></span><span class=\"md-plain\">并不会改变它的类</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item)</span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">如果该项目不是列表的一部分，它可以被强制归入的任何类别</span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (multiple-item)</span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 如果列表中的每个项目都可以被强制转换为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 对象</span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>number</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer``list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real text</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">被标识为类</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>number</code></span><span class=\"md-plain\">的值是类</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\">或类</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span><span class=\"md-plain\">的真实值。</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX file</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">see </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX file</code></span><span class=\"md-plain\">是一个与</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\">类等价的伪类。</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer list</code></span><span class=\"md-plain\"> (single-item)</span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">在强制转换为</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\">时，任何小数部分都被舍入。将</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span><span class=\"md-plain\">强制转换为</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>number</code></span><span class=\"md-plain\">并不会改变它的类</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>record</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">所有标签都会在强制过程中丢失，生成的列表也无法强制回一条记录。</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>reference</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">被引用对象可以强制归属的任何类</span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>list</code></span><span class=\"md-plain\"> (single-item)</span></span></td>\n<td> </td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer``list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">只有当 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 对象代表一个适当的数字时，才能强制 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer</code></span><span class=\"md-plain\"> 或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real</code></span><span class=\"md-plain\"> 。</span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>unit types</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>integer``list</code></span><span class=\"md-plain\"> (single-item) </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>real``text</code></span></span></td>\n<td><span class=\"td-span\"><span class=\"md-plain\">可以强制在同一类别的单位类型之间转换，例如'英寸'到'公里'(长度)或'加仑'到'升'(液体体积)。</span></span></td>\n</tr>\n</tbody>\n</table>\n</figure>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.6 Scripting Additions - 添加脚本</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本附加文件是一个文件或捆绑包，可提供处理程序，用于在脚本中执行命令和强制命令。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">本指南中描述的许多命令都在 macOS 的标准添加脚本中进行了定义。这些命令存储在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/System/Library/ScriptingAdditions</code></span><span class=\"md-plain\"> 的文件 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>StandardAdditions.osax</code></span><span class=\"md-plain\"> 中，任何脚本均可使用。你可以在脚本编辑器中打开该文件，查看标准附加功能的术语。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s \"><strong><span class=\"md-plain\">Note:</span></strong></span><span class=\"md-plain\"> A script can obtain the location of the Standard Additions with this script statement, which uses the </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>path to (folder)</code></span><span class=\"md-plain\"> command:</span> <span class=\"md-plain\">注：脚本可通过该脚本语句获取标准附加文件的位置，该语句使用 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html#//apple_ref/doc/uid/TP40000983-CH216-SW19\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>path to (folder)</code></span></a></span><span class=\"md-plain\"> 命令：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">path</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">scripting</span> <span class=\"cm-keyword\">additions</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-keyword\">text</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"Hard_Disk:System:Library:ScriptingAdditions:\"</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">添加的脚本可嵌入捆绑的脚本小程序中，方法是将它们放在捆绑程序 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Contents/Resources/</code></span><span class=\"md-plain\"> 文件夹内名为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Scripting Additions</code></span><span class=\"md-plain\"> 的文件夹中（注意 \"脚本 \"和 \"添加 \"之间的空格）。请注意，在编辑捆绑的小程序时，脚本编辑器不会查找嵌入的脚本附加文件。在脚本开发过程中，任何所需的脚本附加文件都必须正确安装在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/System/ScriptingAdditions</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/Library/ScriptingAdditions</code></span><span class=\"md-plain\"> 或 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>~/Library/ScriptingAdditions</code></span><span class=\"md-plain\"> 中，以便脚本编辑器可以找到它们。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">开发人员可以创建自己的脚本添加，如技术说明 TN1164，</span><span class=\"md-pair-s \"><em><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/technotes/tn1164/_index.html#//apple_ref/doc/uid/DTS10003003\"><span class=\"md-plain\">Scripting Additions for Mac OS X</span></a></span></em></span><span class=\"md-plain\">中所述。有关相关概念信息，请参阅 </span><span class=\"md-pair-s \"><em><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/AppleScriptX.html#//apple_ref/doc/uid/10000156i\"><span class=\"md-plain\">AppleScript Overview</span></a></span></em></span><span class=\"md-plain\"> ，尤其是</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptX/Concepts/osa.html#//apple_ref/doc/uid/TP40001571\"><span class=\"md-plain\">Open Scripting Architecture</span></a></span><span class=\"md-plain\">一章。</span></p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.7 Commands Overview - 命令概述</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">命令是 AppleScript 语句中用于请求执行操作的一个单词或一系列单词。每条命令都针对一个目标，即响应命令的对象。目标通常是应用程序对象（存储在应用程序或其文档中并由应用程序管理的对象，如窗口或文档）或 macOS 中的对象。不过，它也可以是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象或当前脚本中的一个值。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">命令通常会返回结果。例如， </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html#//apple_ref/doc/uid/TP40000983-CH216-SW12\"><span class=\"md-plain\">display dialog</span></a></span><span class=\"md-plain\"> 命令会返回一条记录，其中可能包含文本、按钮名称和其他信息。脚本可以检查这条记录，以确定下一步的操作。你可以将命令的结果赋值给你定义的变量，或通过预定义的 AppleScript </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>result</code></span><span class=\"md-plain\"> 变量来访问它。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.7.1 Types of Commands - 命令类型</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本可以使用以下几种命令：</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 命令是内置于 AppleScript 语言中的命令。目前有五个这样的命令： </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>get</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>set</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>count</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>copy</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>run</code></span><span class=\"md-plain\"> 。除了 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>copy</code></span><span class=\"md-plain\"> 之外，这些命令中的每一个也可以由应用程序实现。也就是说，该命令有一个适用于 AppleScript 对象的 AppleScript 版本，但应用程序可以定义自己的版本来适用于它定义的对象类型。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本添加命令是通过</span><span class=\"md-meta-i-c  md-link\"><a href=\"applewebdata://BE961DC6-7ABA-4896-9287-4947EA567604#//apple_ref/doc/uid/TP40000983-CH218-SW3\"><span class=\"md-plain\">Scripting Additions</span></a></span><span class=\"md-plain\">中描述的机制实现的命令。尽管任何人都可以创建脚本添加（请参阅技术说明 TN1164，</span><span class=\"md-pair-s \"><em><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/technotes/tn1164/_index.html#//apple_ref/doc/uid/DTS10003003\"><span class=\"md-plain\">Scripting Additions for Mac OS X</span></a></span></em></span><span class=\"md-plain\">），但本指南仅记录来自 Apple 作为 macOS 的一部分提供的标准添加的脚本添加命令。这些命令适用于所有脚本。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">用户自定义命令是由 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\"> 对象中定义的处理程序执行的命令。要在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句之外调用用户定义的命令，只需使用该命令的名称并为其所需的任何参数提供值即可。命令将使用当前脚本作为目标。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">要在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句中调用用户定义的命令，请参阅在 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-SW1\"><span class=\"md-plain\">Calling Handlers in a tell Statement</span></a></span><span class=\"md-plain\">。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">应用程序命令是由可编写脚本的应用程序定义的命令，用于访问可编写脚本的功能。它们通常包含在针对应用程序的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句中。通过在脚本编辑器中检查应用程序的字典，可以确定应用程序支持哪些命令。</span> <span class=\"md-plain\">macOS 随附的可编写脚本的应用程序，如 Finder 和 System Events 应用程序（位于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/System/Library/CoreServices</code></span><span class=\"md-plain\"> ），提供了许多有用的脚本命令。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">第三方脚本应用程序也提供可以在脚本中使用的命令。许多应用程序支持 TN2106 技术注释《</span><span class=\"md-pair-s \"><em><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/technotes/tn2002/tn2106.html#//apple_ref/doc/uid/DTS10003199\"><span class=\"md-plain\">Scripting Interface Guidelines</span></a></span></em></span><span class=\"md-plain\">》中描述的全部或部分标准命令。这些命令包括 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>delete</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>duplicate</code></span><span class=\"md-plain\"> 、 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>exists</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>move</code></span><span class=\"md-plain\"> ，以及 AppleScript 命令的应用程序实现，如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>get</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>set</code></span><span class=\"md-plain\"> 。</span></p>\n</li>\n</ul>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.7.2 Target - 目标</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有两种方法可以显式指定对象作为命令的目标：将其作为命令的直接参数提供（在下一节中介绍）或将其指定为 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句的目标包含该命令。如果脚本未使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句显式指定目标，并且该目标不是由脚本中的处理程序或 AppleScript 本身处理，则会将其发送到继承链中的下一个对象（请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html#//apple_ref/doc/uid/TP40000983-CH207-SW15\"><span class=\"md-plain\">The AppleScript Inheritance Chain</span></a></span><span class=\"md-plain\">）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在下面的脚本中， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>get</code></span><span class=\"md-plain\"> 命令的目标是对象指定符 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name of first window</code></span><span class=\"md-plain\"> 。由于外层的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句指定了 Finder 应用程序，因此完整的指定符是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name of first window of application \"Finder\"</code></span><span class=\"md-plain\"> ，而获取和返回所请求信息的正是 Finder 应用程序。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">get</span> <span class=\"cm-keyword\">name</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">first</span> <span class=\"cm-keyword\">window</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">当命令以应用程序为目标时，结果可能是应用程序对象。如果是这样，以结果对象为目标的后续语句将被发送到应用程序。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本也可以通过使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>Note</code></span><span class=\"md-plain\"> 语句导入的应用程序命令来隐式地指定目标。例如，下面脚本中的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>extract address</code></span><span class=\"md-plain\"> 命令以 Mail 应用程序为目标，因为该命令是从 Mail 中导入的：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">use</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Mail\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">extract</span> <span class=\"cm-keyword\">address</span> <span class=\"cm-keyword\">from</span> <span class=\"cm-string\">\"John Doe &lt;jdoe@example.com&gt;\"</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.7.3 Direct Parameter - 直接参数</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接参数是一个值，通常是一个对象说明符，紧挨着命令出现，用于指定命令的目标。并非所有命令都有直接参数。如果命令可以有直接参数，则会在命令定义中注明。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在下面的语句中，对象指定符 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>last file of window 1 of application \"Finder\"</code></span><span class=\"md-plain\"> 是 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>duplicate</code></span><span class=\"md-plain\"> 命令的直接参数：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">duplicate last file of window 1 of application \"Finder\"</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">直接参数通常紧接在命令之后，但也可能紧接在命令之前。这对于某些命令来说更容易阅读，例如本例中的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>exists</code></span><span class=\"md-plain\"> ：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">if</span> <span class=\"cm-keyword\">file</span> <span class=\"cm-string\">\"semaphore\"</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span> <span class=\"cm-keyword\">exists</span> <span class=\"cm-keyword\">then</span></span><br> <span role=\"presentation\">   <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">continue</span> <span class=\"cm-keyword\">processing</span><span class=\"cm-operator cm-apl-innerProduct\">...</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">if</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句为其中包含的所有命令指定了默认目标，因此直接参数是可选的。下面示例的结果与上例相同：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">last</span> <span class=\"cm-keyword\">file</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">window</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">duplicate</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.7.4 Parameters That Specify Locations - 指定位置的参数</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">许多命令都有指定位置的参数。位置可以是插入点，也可以是其他对象。插入点是可以添加对象的位置。</span> <span class=\"md-plain\">在下面的示例中， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>to</code></span><span class=\"md-plain\"> 参数指定了要移动第一段的位置。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>duplicate</code></span><span class=\"md-plain\"> 命令中 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>to</code></span><span class=\"md-plain\"> 参数的值是相对对象指定符 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>before paragraph 4</code></span><span class=\"md-plain\"> ，它是一个插入点。AppleScript 用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句的目标 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>front document of application \"TextEdit\"</code></span><span class=\"md-plain\"> 来完成指定。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">front</span> <span class=\"cm-keyword\">document</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">duplicate</span> <span class=\"cm-keyword\">paragraph</span> <span class=\"cm-number\">1</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">before</span> <span class=\"cm-keyword\">paragraph</span> <span class=\"cm-number\">4</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>paragraph 1</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>before paragraph 4</code></span><span class=\"md-plain\"> 分别称为索引和相对引用。更多信息，请参阅参考</span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_reference_forms.html#//apple_ref/doc/uid/TP40000983-CH4g-120522\"><span class=\"md-plain\">Reference Forms</span></a></span><span class=\"md-plain\">。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.8 AppleScript Error Handling - AppleScript 错误处理</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在脚本执行过程中，由于与 macOS 的交互、应用脚本命令中遇到的问题或脚本本身的语句导致的问题，可能会发生错误。发生错误时，AppleScript 会停止在当前位置执行，发出错误信号，并在调用链中查找可以处理错误的脚本语句。也就是说，它会查找发生错误位置周围最近的错误处理代码块。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本可以通过将可能遇到错误的语句括在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句中来处理错误。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句包括一个 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>on error</code></span><span class=\"md-plain\"> 部分，如果发生错误，该部分将被调用。AppleScript 会将错误信息（包括错误编号和错误信息）传递给 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>on error</code></span><span class=\"md-plain\"> 部分。这样，脚本就可以检查错误编号并显示相关信息。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果错误发生在未提供 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句的处理程序中，AppleScript 会查找调用处理程序的外层 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句。如果调用链中没有任何调用包含在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句中，AppleScript 会停止脚本的执行并显示错误信息（对于 -128 以外的任何错误编号，如下所述）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>error</code></span><span class=\"md-plain\"> 语句直接发出错误信号。这样做会调用 AppleScript 的错误处理机制，该机制会查找外层的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句来处理错误。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有些 \"错误 \"是命令正常运行的结果。例如，如果用户点击取消按钮， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>display dialog</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>choose file</code></span><span class=\"md-plain\"> 等命令会发出 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>error –128</code></span><span class=\"md-plain\"> （用户取消）信号。脚本通常会处理用户取消错误，以确保正常运行。有关如何处理的示例，请参阅 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>display dialog</code></span><span class=\"md-plain\"> 命令的示例部分。如果脚本中没有处理 -128 错误的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句，AppleScript 会停止脚本的执行，但不会显示任何错误信息。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有关相关信息，请参阅结果 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_lexical_conventions.html#//apple_ref/doc/uid/TP40000983-CH214-SW19\"><span class=\"md-plain\">Results</span></a></span><span class=\"md-plain\">, </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-129657\"><span class=\"md-plain\">error Statements</span></a></span><span class=\"md-plain\">, </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-128973\"><span class=\"md-plain\">try Statements</span></a></span><span class=\"md-plain\">, </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_error_codes.html#//apple_ref/doc/uid/TP40000983-CH220-SW5\"><span class=\"md-plain\">Error Numbers and Error Messages</span></a></span><span class=\"md-plain\">, and </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_error_xmpls.html#//apple_ref/doc/uid/TP40000983-CH221-SW1\"><span class=\"md-plain\">Working with Errors</span></a></span><span class=\"md-plain\">.</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9 Global Constants in AppleScript - AppleScript 中的全局常量</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 定义了许多全局常量，你可以在脚本的任何地方使用它们。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1 AppleScript Constant - AppleScript 常量</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">通过全局常量 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>AppleScript</code></span><span class=\"md-plain\"> ，您可以访问在整个脚本中使用的属性。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如</span><span class=\"md-meta-i-c  md-link\"><a href=\"applewebdata://BE961DC6-7ABA-4896-9287-4947EA567604#//apple_ref/doc/uid/TP40000983-CH218-SW6\"><span class=\"md-plain\">version</span></a></span><span class=\"md-plain\">部分所示，你可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>AppleScript</code></span><span class=\"md-plain\"> 标识符本身来区分 AppleScript 属性和当前目标的同名属性。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下文将介绍 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>AppleScript</code></span><span class=\"md-plain\"> 的其他属性。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h5 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1.1 pi </span></h5>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">这个 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>mathematical</code></span><span class=\"md-plain\"> 值表示圆周长与直径之比。它被定义为实数，值为 3.14159265359。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">例如，下面的语句计算半径为 7 的圆的面积：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">set circleArea to pi * 7 * 7 --result: 153.9380400259</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h5 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1.2 result - 返回</span></h5>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">执行语句时，AppleScript 会将结果值（如果有）存储到预定义属性 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>result</code></span><span class=\"md-plain\"> 中。在执行另一条产生值的语句之前，该值一直保持不变。在执行产生结果的语句之前， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>result</code></span><span class=\"md-plain\"> 的值是未定义的。您可以在脚本窗口的 \"结果 \"窗格中查看脚本编辑器中的结果。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注意：当脚本执行过程中发生错误时，AppleScript 会发出错误信号。它不会在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>result</code></span><span class=\"md-plain\"> 属性中返回错误信息。有关详细信息，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"applewebdata://BE961DC6-7ABA-4896-9287-4947EA567604#//apple_ref/doc/uid/TP40000983-CH218-SW10\"><span class=\"md-plain\">AppleScript Error Handling</span></a></span><span class=\"md-plain\">。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"> </p>\n<h5 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1.3 Text Constants - 文本常量</span></h5>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 定义了文本属性 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>space</code></span><span class=\"md-plain\"> , </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tab</code></span><span class=\"md-plain\"> , </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>return</code></span><span class=\"md-plain\"> , </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>linefeed</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>quote</code></span><span class=\"md-plain\"> 。使用这些属性作为文本常量，可以有效地表示空白或双引号 ( </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"</code></span><span class=\"md-plain\"> ) 字符。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 类的 \"特殊字符串字符 \"部分对它们进行了描述。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h5 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1.4 text item delimiters - 文本项分隔符</span></h5>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 提供了用于处理文本的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 属性。该属性由一系列字符串组成，当 AppleScript 将列表强制转换为文本或从文本字符串中获取文本项时，这些字符串将用作分隔符。当获取 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text items</code></span><span class=\"md-plain\"> 文本时，所有字符串都用作分隔符。将列表强制转换为文本时，第一项将用作分隔符。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">注意：在 OS X Snow Leopard v10.6 之前，AppleScript 在获取 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text items</code></span><span class=\"md-plain\"> 时只使用列表中的第一个分隔符。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">由于 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 尊重 AppleScript 2.0 中的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>considering</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>ignoring</code></span><span class=\"md-plain\"> 属性，因此默认情况下分隔符不区分大小写。以前，它们总是区分大小写。要执行以前的行为，请添加一条明确的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>considering case</code></span><span class=\"md-plain\"> 语句。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以获取和设置 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 属性的当前值。通常情况下，AppleScript 不使用任何分隔符。例如，如果文本分隔符没有明确更改，语句</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">{\"bread\", \"milk\", \"butter\", 10.45}  as string</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">返回以下内容：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">\"breadmilkbutter10.45\"</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">为便于打印或显示，通常最好将 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 设置为更易于阅读的值。例如，脚本</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters to {\", \"}</span></span><br> <span role=\"presentation\">{<span class=\"cm-string\">\"bread\"</span><span class=\"cm-function cm-apl-catenate\">,</span> <span class=\"cm-string\">\"milk\"</span><span class=\"cm-function cm-apl-catenate\">,</span> <span class=\"cm-string\">\"butter\"</span><span class=\"cm-function cm-apl-catenate\">,</span> <span class=\"cm-number\">10.45</span>}  <span class=\"cm-keyword\">as</span> <span class=\"cm-keyword\">string</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">返回此结果：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">\"bread, milk, butter, 10.45\"</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 属性可用于从路径名中提取单个名称。例如，脚本</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters to {\":\"}</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">get</span> <span class=\"cm-keyword\">last</span> <span class=\"cm-keyword\">text</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-string\">\"Hard Disk:CD Contents:Release Notes\"</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">返回结果 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"Release Notes\"</code></span><span class=\"md-plain\"> 。</span> <span class=\"md-plain\">如果在脚本编辑器中更改了 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 属性，在恢复其先前值或退出脚本编辑器并再次启动脚本编辑器之前，该属性将保持不变。如果在脚本应用程序中更改 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> ，则该应用程序中的分隔符将保持不变，直到恢复其先前的值或脚本应用程序退出为止；但脚本编辑器或运行的其他脚本应用程序中的分隔符不会更改。</span> <span class=\"md-plain\">如果出现错误，脚本通常会使用错误处理程序将 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text item delimiters</code></span><span class=\"md-plain\"> 属性重置为原来的值（有关处理错误的更多信息，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"applewebdata://BE961DC6-7ABA-4896-9287-4947EA567604#//apple_ref/doc/uid/TP40000983-CH218-SW10\"><span class=\"md-plain\">AppleScript Error Handling</span></a></span><span class=\"md-plain\">）：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">savedDelimiters</span> <span class=\"cm-keyword\">to</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters to {\"**\"}</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--other</span> <span class=\"cm-keyword\">script</span> <span class=\"cm-keyword\">statements</span><span class=\"cm-operator cm-apl-innerProduct\">...</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--now</span> <span class=\"cm-keyword\">reset</span> <span class=\"cm-keyword\">the</span> <span class=\"cm-keyword\">text</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-keyword\">delimiters:</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters to savedDelimiters</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">on</span> <span class=\"cm-keyword\">error</span> <span class=\"cm-keyword\">m</span> <span class=\"cm-keyword\">number</span> <span class=\"cm-keyword\">n</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--also</span> <span class=\"cm-keyword\">reset</span> <span class=\"cm-keyword\">text</span> <span class=\"cm-keyword\">item</span> <span class=\"cm-keyword\">delimiters</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-keyword\">case</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">an</span> <span class=\"cm-keyword\">error:</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">set</span> <span class=\"cm-keyword\">AppleScript</span><span class=\"cm-string\">'s text item delimiters to savedDelimiters</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">--and</span> <span class=\"cm-keyword\">resignal</span> <span class=\"cm-keyword\">the</span> <span class=\"cm-keyword\">error:</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">error</span> <span class=\"cm-keyword\">m</span> <span class=\"cm-keyword\">number</span> <span class=\"cm-keyword\">n</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\">​</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h5 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.1.5 version - 版本</span></h5>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此属性提供 AppleScript 的当前版本。下面的脚本演示了如何检查版本是否大于或等于 1.9 版。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>if</code></span><span class=\"md-plain\"> 语句被包裹在 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>considering numeric strings</code></span><span class=\"md-plain\"> 语句中，这样 AppleScript 的版本（如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>1.10.6</code></span><span class=\"md-plain\"> ）就会比 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>1.9</code></span><span class=\"md-plain\"> 大。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">considering</span> <span class=\"cm-keyword\">numeric</span> <span class=\"cm-keyword\">strings</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">if</span> <span class=\"cm-keyword\">version</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">AppleScript</span> <span class=\"cm-keyword\">as</span> <span class=\"cm-keyword\">string</span> <span class=\"cm-function cm-apl-greaterThanOrEqual\">≥</span> <span class=\"cm-string\">\"1.9\"</span> <span class=\"cm-keyword\">then</span></span><br> <span role=\"presentation\">        <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">Perform</span> <span class=\"cm-keyword\">operations</span> <span class=\"cm-keyword\">that</span> <span class=\"cm-keyword\">depend</span> <span class=\"cm-keyword\">on</span> <span class=\"cm-keyword\">version</span> <span class=\"cm-number\">1.9</span> <span class=\"cm-keyword\">or</span> <span class=\"cm-keyword\">greater</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">else</span></span><br> <span role=\"presentation\">        <span class=\"cm-keyword\">--</span> <span class=\"cm-keyword\">Handle</span> <span class=\"cm-keyword\">case</span> <span class=\"cm-keyword\">where</span> <span class=\"cm-keyword\">version</span> <span class=\"cm-keyword\">is</span> <span class=\"cm-keyword\">not</span> <span class=\"cm-keyword\">high</span> <span class=\"cm-keyword\">enough</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">if</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">considering</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">应用程序可以拥有自己的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>version</code></span><span class=\"md-plain\"> 属性，因此要明确访问 AppleScript 版本，可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>version of AppleScript</code></span><span class=\"md-plain\"> 短语。这将在针对另一个应用程序的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 代码块中起作用，例如下面的代码：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"apl\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">tell</span> <span class=\"cm-keyword\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">version</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"10.5.1\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">version</span> <span class=\"cm-keyword\">of</span> <span class=\"cm-keyword\">AppleScript</span> <span class=\"cm-keyword\">--result:</span> <span class=\"cm-string\">\"2.0\"</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">end</span> <span class=\"cm-keyword\">tell</span></span><br> <span role=\"presentation\">​</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.2 current application Constant - current application常量</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>current application</code></span><span class=\"md-plain\"> 常量指的是执行当前 AppleScript 脚本的应用程序（例如脚本编辑器）。由于当前应用程序是 AppleScript 的父应用程序（请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html#//apple_ref/doc/uid/TP40000983-CH207-SW15\"><span class=\"md-plain\">The AppleScript Inheritance Chain</span></a></span><span class=\"md-plain\">），因此它有机会处理当前脚本或 AppleScript 未处理的命令。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>current application</code></span><span class=\"md-plain\"> 常量是一个对象说明符--如果向 AppleScript 询问其值，结果就是对象说明符：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">get current application --result: current application</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">但是，如果要求 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>name of current application</code></span><span class=\"md-plain\"> ，AppleScript 会解析对象指定符，并返回当前应用程序的名称：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">name of current application --result: \"Script Editor\"</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.3 missing value Constant </span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>missing value</code></span><span class=\"md-plain\"> 常量是缺失或未初始化信息的占位符。</span> <span class=\"md-plain\">例如，以下语句使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>missing value</code></span><span class=\"md-plain\"> 常量来判断变量是否发生了变化：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"javascript\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">myVariable</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">missing</span> <span class=\"cm-variable\">value</span></span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">perform</span> <span class=\"cm-variable\">operations</span> <span class=\"cm-variable\">that</span> <span class=\"cm-variable\">might</span> <span class=\"cm-variable\">change</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">value</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">myVariable</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">if</span> <span class=\"cm-variable\">myVariable</span> <span class=\"cm-variable\">is</span> <span class=\"cm-variable\">equal</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">missing</span> <span class=\"cm-variable\">value</span> <span class=\"cm-variable\">then</span></span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">value</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">variable</span> <span class=\"cm-variable\">never</span> <span class=\"cm-variable\">changed</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">else</span></span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">value</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">variable</span> <span class=\"cm-variable\">did</span> <span class=\"cm-variable\">change</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-keyword\">if</span></span><br> <span role=\"presentation\">​</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.9.4 true, false Constants </span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 定义了布尔常数 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>true</code></span><span class=\"md-plain\"> 和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>false</code></span><span class=\"md-plain\"> 。这些常量由 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>boolean</code></span><span class=\"md-plain\"> 类描述。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.10 The it and me Keywords</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript定义关键字</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>me</code></span><span class=\"md-plain\">指向当前脚本，关键字</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>it</code></span><span class=\"md-plain\">指向当前目标。(* </span><span class=\"md-pair-s \"><em><span class=\"md-plain\">当前脚本</span></em></span> <span class=\"md-pair-s \"><em><span class=\"md-plain\">是当前正在执行的脚本;</span></em></span> <span class=\"md-pair-s \"><em><span class=\"md-plain\">当前目标</span></em></span><span class=\"md-plain\"> *是命令的当前默认目标。)它还将“my”定义为“of me”的同义词，将“its”定义为“of It”的同义词</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果一个脚本没有指向任何东西，</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>it</code></span><span class=\"md-plain\">和</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>me</code></span><span class=\"md-plain\">指向相同的东西——脚本，如下面的例子所示:</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-operator\">--</span> <span class=\"cm-variable\">At</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">top</span><span class=\"cm-operator\">-</span><span class=\"cm-variable\">level</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">script</span>:</span><br> <span role=\"presentation\"><span class=\"cm-variable\">me</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-variable\">«script»</span> (<span class=\"cm-variable\">顶级脚本对象</span>)</span><br> <span role=\"presentation\"><span class=\"cm-variable\">it</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-variable\">«script»</span> (<span class=\"cm-variable\">和</span><span class=\"cm-string-2\">`it`</span><span class=\"cm-variable\">一样，因为还没有设定目标</span>)</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\"> 语句指定了默认目标。在下面的示例中，默认目标是 Finder 应用程序：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-operator\">--</span> <span class=\"cm-variable\">Within</span> <span class=\"cm-variable\">a</span> <span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">block</span>:</span><br> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span> <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">sets</span> <span class=\"cm-variable\">target</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">me</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-variable\">«script»</span> (<span class=\"cm-variable\">still</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">top</span><span class=\"cm-operator\">-</span><span class=\"cm-variable\">level</span> <span class=\"cm-variable\">script</span> <span class=\"cm-variable\">object</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">it</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span> (<span class=\"cm-variable\">target</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">statement</span>)</span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以使用单词' of me '或' my '来表示命令的目标是当前脚本，而不是</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\">语句的目标。在下面的例子中，单词</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>my</code></span><span class=\"md-plain\">表明</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>minimumValue()</code></span><span class=\"md-plain\">处理程序是由脚本定义的，而不是由Finder定义的:</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">set</span> <span class=\"cm-variable\">fileCount</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">count</span> <span class=\"cm-variable\">files</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-variable\">front</span> <span class=\"cm-variable\">window</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">set</span> <span class=\"cm-variable\">myCount</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">my</span> <span class=\"cm-variable\">minimumValue</span>(<span class=\"cm-variable\">fileCount</span>, <span class=\"cm-number\">100</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span><span class=\"cm-keyword\">do</span> <span class=\"cm-variable\">something</span> <span class=\"cm-keyword\">with</span> <span class=\"cm-variable\">up</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">first</span> <span class=\"cm-number\">100</span> <span class=\"cm-variable\">files…</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你也可以使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>of me</code></span><span class=\"md-plain\">或</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>my</code></span><span class=\"md-plain\">来区分脚本属性和对象属性。假设打开了一个名为Simple.rtf的TextEdit文档:</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">document</span> <span class=\"cm-number\">1</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">name</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"Simple.rtf\"</span> (<span class=\"cm-variable\">implicitly</span> <span class=\"cm-variable\">uses</span> <span class=\"cm-variable\">target</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">tell</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">name</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">it</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"Simple.rtf\"</span> (<span class=\"cm-variable\">specifies</span> <span class=\"cm-variable\">target</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">tell</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">me</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-variable\">«script»</span> (<span class=\"cm-variable\">top</span><span class=\"cm-operator\">-</span><span class=\"cm-variable\">level</span> <span class=\"cm-variable\">script</span> <span class=\"cm-variable\">object</span>, <span class=\"cm-variable\">not</span> <span class=\"cm-variable\">target</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">tell</span>)</span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面的例子展示了如何在Finder的</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\">语句中指定不同的</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>version</code></span><span class=\"md-plain\">属性。Finder是默认目标，但使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>version of me</code></span><span class=\"md-plain\">、</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>my version</code></span><span class=\"md-plain\">或</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>AppleScript</code></span><span class=\"md-plain\">可以指定顶层</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\">对象的版本。(顶层的</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>script</code></span><span class=\"md-plain\">对象返回AppleScript版本，因为它继承自AppleScript,详见 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_script_objects.html#//apple_ref/doc/uid/TP40000983-CH207-SW15\"><span class=\"md-plain\">The AppleScript Inheritance Chain</span></a></span><span class=\"md-plain\">）。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">version</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"10.5.1\"</span> (<span class=\"cm-variable\">Finder</span> <span class=\"cm-variable\">version</span> <span class=\"cm-variable\">is</span> <span class=\"cm-variable\">the</span> <span class=\"cm-keyword\">default</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">block</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">its</span> <span class=\"cm-variable\">version</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"10.5.1\"</span> (<span class=\"cm-variable\">specifically</span> <span class=\"cm-variable\">asks</span> <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">Finder</span> <span class=\"cm-variable\">version</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">version</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">me</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"2.0\"</span> (<span class=\"cm-variable\">AppleScript</span> <span class=\"cm-variable\">version</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">my</span> <span class=\"cm-variable\">version</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"2.0\"</span> (<span class=\"cm-variable\">AppleScript</span> <span class=\"cm-variable\">version</span>)</span><br> <span role=\"presentation\">    <span class=\"cm-variable\">version</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">AppleScript</span> <span class=\"cm-operator\">--</span><span class=\"cm-variable\">result</span>: <span class=\"cm-string\">\"2.0\"</span> (<span class=\"cm-variable\">AppleScript</span> <span class=\"cm-variable\">version</span>)</span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">tell</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">有关在筛选器引用中使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>it</code></span><span class=\"md-plain\"> 的信息，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_reference_forms.html#//apple_ref/doc/uid/TP40000983-CH4g-BAJJHEFE\"><span class=\"md-plain\">Filter</span></a></span><span class=\"md-plain\">引用表格的讨论部分。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.11 Aliases and Files 别名和文件</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">要引用 macOS 文件系统中的项目和位置，可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span><span class=\"md-plain\"> 对象和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象。</span> <span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span><span class=\"md-plain\"> 对象是对现有文件系统对象的动态引用。由于它是动态的，因此即使指定的文件系统对象被移动或重命名，它也能保持与该对象的链接。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象代表文件系统中特定位置的特定文件。它可以指当前不存在的项目，如将要创建的文件的名称和位置。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象不是动态的，它总是指向同一个位置，即使有不同的项目被移动到该位置。 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX file</code></span><span class=\"md-plain\"> 伪类与 file 大致同义： </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX file</code></span><span class=\"md-plain\"> 指定符评估 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象，但它们对名称使用不同的语义，详见</span><span class=\"md-meta-i-c  md-link\"><a href=\"applewebdata://BE961DC6-7ABA-4896-9287-4947EA567604#//apple_ref/doc/uid/TP40000983-CH218-SW11\"><span class=\"md-plain\">Specifying Paths</span></a></span><span class=\"md-plain\">。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">The following is the recommended usage for these types:</span> <span class=\"md-plain\">以下是这些类型的推荐用法：</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span><span class=\"md-plain\"> 对象引用现有文件系统对象。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象引用尚不存在的文件。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果要使用 POSIX 路径指定文件，请使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX file</code></span><span class=\"md-plain\"> 指定符。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下文将介绍如何按路径指定文件系统对象，以及如何在脚本中使用它们。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.11.1 Specifying Paths - 指定路径</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以通过提供名称指定符来创建 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span><span class=\"md-plain\"> 对象和 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象，其中名称是文件系统中项目的路径。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于别名和文件说明符，路径是一个HFS路径，格式为</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"disk:item:subitem:subsubitem:…:item\"</code></span><span class=\"md-plain\">。例如，</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"Hard_Disk:Applications:Mail. \"</code></span><span class=\"md-plain\"> app\"</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>是邮件应用程序的HFS路径，假设你的启动驱动器名为</code></span><span class=\"md-plain\">\"Hard_Disk\"`。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以冒号开头的HFS路径，如</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>:folder:file</code></span><span class=\"md-plain\">，相对于HFS工作目录进行解析。但是，不鼓励使用它们，因为HFS工作目录的位置是未指定的，并且没有办法从AppleScript控制它。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">对于POSIX文件说明符，路径是POSIX路径，形式为</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>/item/subitem/subsubitem/…/item</code></span><span class=\"md-plain\">。启动盘不需要指定磁盘名称。例如，“/Applications/Mail.”是邮件应用程序的POSIX路径。你可以在Finder的Get信息窗口的“Where”字段中看到项目的POSIX路径。尽管名称是POSIX，但POSIX文件标识符可以指向文件夹或磁盘。不支持使用“~”来指定主目录。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">不带斜线的 POSIX 路径，如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"folder/file\"</code></span><span class=\"md-plain\"> ，是相对于 POSIX 工作目录解析的。支持这种方法，但只对从 shell 运行的脚本有用--工作目录就是 shell 中的当前目录。应用程序的 POSIX 工作目录位置未指定。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.11.2 Working With Aliases - 使用别名</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 定义了 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>alias</code></span><span class=\"md-plain\"> 类来表示别名。别名可以存储在变量中，并在整个脚本中使用。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面的脚本首先在变量</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>notesAlias</code></span><span class=\"md-plain\">中为一个已存在的文件创建别名，然后在</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\">语句中使用该变量打开文件。在创建别名之前，它使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\">语句检查别名是否存在，这样即使脚本重复运行，也只创建一次别名。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">notesAlias</span> <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">see</span> <span class=\"cm-keyword\">if</span> <span class=\"cm-variable\">we</span><span class=\"cm-string\">'ve created the alias yet</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">on</span> <span class=\"cm-variable\">error</span></span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span> <span class=\"cm-keyword\">if</span> <span class=\"cm-variable\">not</span>, <span class=\"cm-variable\">create</span> <span class=\"cm-variable\">it</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">error</span> <span class=\"cm-variable\">branch</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">set</span> <span class=\"cm-variable\">notesAlias</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">alias</span> <span class=\"cm-string\">\"Hard_Disk:Users:myUser:Feb_Notes.rtf\"</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\"><span class=\"cm-operator\">--</span> <span class=\"cm-variable\">now</span> <span class=\"cm-variable\">open</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">file</span> <span class=\"cm-variable\">from</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">alias</span>:</span><br> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"TextEdit\"</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">open</span> <span class=\"cm-variable\">notesAlias</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">查找别名引用的对象称为* </span><span class=\"md-pair-s \"><em><span class=\"md-plain\">解析</span></em></span><span class=\"md-plain\"> *别名。AppleScript 2.0仅在运行脚本时才会尝试解析别名。然而，在更早的版本中，AppleScript会尝试在编译时解析别名。</span> <span class=\"md-plain\">运行前面的示例创建别名后，再次运行脚本时，即使文件名或位置发生变化，脚本也能找到原始文件。(不过，如果在重新编译后再次运行脚本，它将创建一个新的别名）。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">通过将别名强制转换为文本，可以从别名中获取 HFS 路径：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">notesAlias as text --result: \"Hard_Disk:Users:myUser:Feb_Notes.rtf\"</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">你可以使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>POSIX path</code></span><span class=\"md-plain\">属性来获取由别名引用的项的POSIX风格路径:</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">POSIX path of notesAlias --result: \"/Feb_Notes.rtf\"</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果一个别名没有引用一个现存的文件系统对象，那么它就是坏的。不能为不存在的对象创建别名，例如计划创建的文件。你可以使用一个</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\">对象，在下一节中描述。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\"> 有关脚本应用程序如何处理用户将一个或多个文件图标放置在其上时收到的别名列表的示例脚本，请参阅 </span><span class=\"md-meta-i-c  md-link\"><a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_about_handlers.html#//apple_ref/doc/uid/TP40000983-CH206-SW16\"><span class=\"md-plain\">open Handlers</span></a></span><span class=\"md-plain\">。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.11.3 Working With Files - 使用文件</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript使用</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\">对象在脚本中表示文件。</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\">对象可以存储在变量中并在整个脚本中使用。下面的脚本首先在变量</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>notesFile</code></span><span class=\"md-plain\">中为一个已存在的文件创建一个</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\">对象，然后在</span><span class=\"md-pair-s\" spellcheck=\"false\"><code>tell</code></span><span class=\"md-plain\">语句中使用该变量来打开文件:</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">notesFile</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">POSIX</span> <span class=\"cm-variable\">file</span> <span class=\"cm-string\">\"/Users/myUser/Feb_Meeting_Notes.rtf\"</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"TextEdit\"</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">open</span> <span class=\"cm-variable\">notesFile</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象为可能不存在的文件指定名称和位置：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">newFile</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">POSIX</span> <span class=\"cm-variable\">file</span> <span class=\"cm-string\">\"/Users/myUser/BrandNewFile.rtf\"</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">同样，可以让用户使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>choose file name</code></span><span class=\"md-plain\"> 命令指定一个新文件，然后使用返回的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象创建文件。在下面的示例中，如果用户取消 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>choose file name</code></span><span class=\"md-plain\"> 对话框，脚本的其余部分将不会执行。如果用户提供了文件名，脚本就会打开文件，必要时创建文件，然后使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>try</code></span><span class=\"md-plain\"> 语句确保在写完文件后关闭文件。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">theFile</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">choose</span> <span class=\"cm-variable\">file</span> <span class=\"cm-variable\">name</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">referenceNumber</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">open</span> <span class=\"cm-keyword\">for</span> <span class=\"cm-variable\">access</span> <span class=\"cm-variable\">theFile</span> <span class=\"cm-keyword\">with</span> <span class=\"cm-variable\">write</span> <span class=\"cm-variable\">permission</span></span><br> <span role=\"presentation\"><span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\">    <span class=\"cm-operator\">--</span> <span class=\"cm-variable\">statements</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">write</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">the</span> <span class=\"cm-variable\">file</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">on</span> <span class=\"cm-variable\">error</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">close</span> <span class=\"cm-variable\">access</span> <span class=\"cm-variable\">referenceNumber</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-keyword\">try</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">close</span> <span class=\"cm-variable\">access</span> <span class=\"cm-variable\">referenceNumber</span></span><br> <span role=\"presentation\">​</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">通常情况下，当你将 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>file</code></span><span class=\"md-plain\"> 对象传递给一个命令，用它来对文件系统中的新项目或现有项目进行操作时，路径中的组件必须存在，命令才能成功。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.12 Remote Applications -远程应用</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果远程计算机上启用了远程应用程序，并且脚本使用 eppc 样式的指定符指定了该计算机，那么脚本就可以将该计算机上的应用程序作为目标。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.12.1 Enabling Remote Applications - 启用远程应用程序</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本要向远程应用程序发送命令，必须满足以下条件：</span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">包含应用程序的计算机和运行脚本的计算机必须通过网络相互连接。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">必须在远程计算机上启用 \"远程 Apple 事件\"（在 \"共享 \"首选项窗格中设置），并提供用户访问权限（可以允许所有用户访问，也可以只允许指定用户访问）。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果指定的远程应用程序没有运行，则必须运行它。</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">编译或运行脚本时，必须以管理员身份进行身份验证。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.12.2 eppc-Style Specifiers - eppc 样式指定器</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">eppc-style 指定符的格式如下：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">eppc://[user[:password]@]IP_address</span></pre>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>ip_address</code></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\"> 可以是十进制形式的数字 IP 地址（四个数字，从 0 到 255，用句号分隔；例如 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>123.23.23.123</code></span><span class=\"md-plain\"> ），也可以是主机名。主机名可以是 Bonjour 名称。</span></p>\n</li>\n</ul>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">以下是有效的 eppc 样式参数示例。如果提供用户名和密码，则无需验证。如果不提供，则可能需要验证。</span></p>\n<figure class=\"md-table-fig table-figure\">\n<table class=\"md-table\">\n<thead>\n<tr class=\"md-end-block\">\n<th><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"eppc://myCoolMac.local\" -- hostname, no user or pwd</code></span></span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"eppc://myUserName:pwd@myCoolMac.local\" -- user, pwd, and hostname</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"eppc://123.23.23.123\" -- IP address, no user or pwd</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"eppc://myUserName:pwd@123.23.23.123\" -- user, pwd, and IP address</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>\"eppc://myUserName@server.company.com\" -- server address, user</code></span></span></td>\n</tr>\n</tbody>\n</table>\n</figure>\n<p class=\"md-end-block md-p\"> </p>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">重要：如果 eppc-style 指定符的某一部分包含非 UTF-8 字符或空白，则必须对其进行 URL 编码：例如，这里的用户名包含一个空格：</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>John%20Smith</code></span><span class=\"md-plain\">.</span></p>\n</blockquote>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.12.3 Targeting Remote Applications - 定位远程应用程序</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以将远程计算机上正在运行的应用程序作为目标，也可以在远程计算机上启动当前未运行的应用程序。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面的示例使用 eppc 样式的指定程序，以远程计算机上的 Finder 为目标。它包含用户名和密码，因此不需要验证。</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">remoteMachine</span> <span class=\"cm-variable\">to</span> <span class=\"cm-string\">\"eppc://userName:pwd@MacName.local\"</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">app</span> <span class=\"cm-string\">\"Finder\"</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">machine</span> <span class=\"cm-variable\">remoteMachine</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">close</span> <span class=\"cm-variable\">front</span> <span class=\"cm-variable\">window</span></span></pre>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">重要提示：如果编译了错误的 eppc 样式地址，则必须退出并重新启动脚本编辑器才能使地址更改生效。</span></p>\n</blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">在某些情况下，你需要使用 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>using terms from</code></span><span class=\"md-plain\"> 语句告诉 AppleScript 针对应用程序的本地版本进行编译。下面的示例就使用了这种技术，告诉远程 Finder 应用程序打开 TextEdit 应用程序：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">remoteFinder</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">machine</span> <span class=\"cm-variable\">¬</span></span><br> <span role=\"presentation\">    <span class=\"cm-string\">\"eppc://myUserName:pwd@123.23.23.123\"</span></span><br>  <br> <span role=\"presentation\"><span class=\"cm-variable\">using</span> <span class=\"cm-variable\">terms</span> <span class=\"cm-variable\">from</span> <span class=\"cm-variable\">application</span> <span class=\"cm-string\">\"Finder\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">tell</span> <span class=\"cm-variable\">remoteFinder</span></span><br> <span role=\"presentation\">        <span class=\"cm-variable\">open</span> <span class=\"cm-variable\">application</span> <span class=\"cm-variable\">file</span> <span class=\"cm-variable\">id</span> <span class=\"cm-string\">\"com.apple.TextEdit\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">end</span> <span class=\"cm-variable\">tell</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">using</span> <span class=\"cm-variable\">terms</span> <span class=\"cm-variable\">from</span></span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">如果在前面的脚本中省略了密码 ( </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>pwd</code></span><span class=\"md-plain\"> )，运行脚本时就必须进行身份验证。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h3 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.13 Debugging AppleScript Scripts - 调试 AppleScript 脚本</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">AppleScript 并不包含内置调试器，但它提供了几种简单的机制来帮助你调试脚本或观察脚本的运行情况。</span></p>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.13.1 Feedback From Your Script - 来自脚本的反馈</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">您可以在脚本中插入各种语句，以显示当前位置和其他信息。最简单的方法是在感兴趣的位置插入蜂鸣声命令：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">beep 3 -- three beeps; a very important part of the script!</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>display dialog</code></span><span class=\"md-plain\"> 命令可以显示脚本中正在发生的信息，与断点一样，它也会停止执行，直到您将其取消（或超时，取决于您传递的参数）。下面的示例显示了当前脚本的位置和一个变量的值：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">display</span> <span class=\"cm-variable\">dialog</span> <span class=\"cm-string\">\"In factorial routine; x = \"</span> <span class=\"cm-operator\">&amp;</span> (<span class=\"cm-variable\">x</span> <span class=\"cm-variable\">as</span> <span class=\"cm-variable\">string</span>)</span></pre>\n<p class=\"md-end-block md-p\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>say</code></span><span class=\"md-plain\"> 命令可以通过说出指定文本来引起您的注意。在下面的示例中， </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>currentClient</code></span><span class=\"md-plain\"> 是一个存储客户名称的 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>text</code></span><span class=\"md-plain\"> 对象：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"\" spellcheck=\"false\"> <span role=\"presentation\">say \"I'm in the clientName handler. The client is \" &amp; currentClient</span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.13.2 Logging - 日志</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">脚本编辑器可以显示脚本执行过程中发送的 Apple 事件日志。在 \"脚本编辑器首选项 \"中，你还可以选择保留最近结果或事件日志的历史记录。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">此外，您还可以在脚本中插入 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>log</code></span><span class=\"md-plain\"> 语句。日志输出会显示在脚本窗口的 \"事件日志 \"窗格中，如果打开了 \"事件日志历史记录 \"窗口，也会显示在该窗口中。</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面的简单示例记录了 </span><span class=\"md-pair-s\" spellcheck=\"false\"><code>repeat with loopVariable (in list)</code></span><span class=\"md-plain\"> 语句中的当前单词：</span></p>\n<pre class=\"md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded\" lang=\"js\" spellcheck=\"false\"> <span role=\"presentation\"><span class=\"cm-variable\">set</span> <span class=\"cm-variable\">wordList</span> <span class=\"cm-variable\">to</span> <span class=\"cm-variable\">words</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-string\">\"Where is the hammer?\"</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">repeat</span> <span class=\"cm-keyword\">with</span> <span class=\"cm-variable\">currentWord</span> <span class=\"cm-keyword\">in</span> <span class=\"cm-variable\">wordList</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">log</span> <span class=\"cm-variable\">currentWord</span></span><br> <span role=\"presentation\">    <span class=\"cm-keyword\">if</span> <span class=\"cm-variable\">contents</span> <span class=\"cm-variable\">of</span> <span class=\"cm-variable\">currentWord</span> <span class=\"cm-variable\">is</span> <span class=\"cm-variable\">equal</span> <span class=\"cm-variable\">to</span> <span class=\"cm-string\">\"hammer\"</span> <span class=\"cm-variable\">then</span></span><br> <span role=\"presentation\">        <span class=\"cm-variable\">display</span> <span class=\"cm-variable\">dialog</span> <span class=\"cm-string\">\"I found the hammer!\"</span></span><br> <span role=\"presentation\">    <span class=\"cm-variable\">end</span> <span class=\"cm-keyword\">if</span></span><br> <span role=\"presentation\"><span class=\"cm-variable\">end</span> <span class=\"cm-variable\">repeat</span></span></pre>\n<p class=\"md-end-block md-p\"> </p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">下面显示了运行脚本时日志中出现的字词： </span></p>\n<figure class=\"md-table-fig table-figure\">\n<table class=\"md-table\">\n<thead>\n<tr class=\"md-end-block\">\n<th><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>(*Where*)</code></span></span></th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>(*is*)</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>(*the*)</code></span></span></td>\n</tr>\n<tr class=\"md-end-block\">\n<td><span class=\"td-span\"><span class=\"md-pair-s\" spellcheck=\"false\"><code>(*hammer*)</code></span></span></td>\n</tr>\n</tbody>\n</table>\n</figure>\n<p class=\"md-end-block md-p\"> </p>\n<h4 class=\"md-end-block md-heading\"><span class=\"md-plain\">2.13.3 Third Party Debuggers 第三方调试器</span></h4>\n<p class=\"md-end-block md-p\"><span class=\"md-plain md-expand\">如果需要全功能调试功能，可以使用功能强大的第三方 AppleScript 调试器。</span></p>",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/37/2022-08-01-06.58.16-2894810266061428586_5823209264.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "develop"
            ],
            "date_published": "2023-08-21T17:25:18+08:00",
            "date_modified": "2023-08-21T17:25:18+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/applescript-gai-shu/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/applescript-gai-shu/",
            "title": "AppleScript 概述",
            "summary": "1. 什么是 AppleScript AppleScript 是苹果创建的一个脚本语言。它允许用户直接控制可编写脚本的 Macintosh 应用程序，以及 MacOS 本身的一部分。您可以创建脚本ーー一组书面指令ーー来自动执行重复的任务，结合多个可编写脚本的应用程序的特性，并创建复杂的工作流。 注意:&hellip;",
            "content_html": "<h2 id=\"1-什么是-applescript\">1. 什么是 AppleScript</h2>\n<p><strong>AppleScript 是苹果创建的一个脚本语言。它允许用户直接控制可编写脚本的 Macintosh 应用程序，以及 MacOS 本身的一部分。您可以创建脚本ーー一组书面指令ーー来自动执行重复的任务，结合多个可编写脚本的应用程序的特性，并创建复杂的工作流。</strong></p>\n<blockquote>\n<p>注意: 苹果还提供了 <code>Automator</code> 应用程序，该应用程序允许用户通过在图形环境中将现成的操作连接在一起来实现常见任务的自动化。有关更多信息，请参见 Automator 文档。</p>\n</blockquote>\n<p>可编写脚本的应用程序是可以由脚本控制的应用程序。对于 AppleScript，这意味着对应用程序间消息(称为 Apple 事件)作出响应，这些消息在脚本命令针对应用程序时发送。(Apple 事件也可以直接从其他应用程序和 macOS 发送。)</p>\n<p>AppleScript 本身提供了非常少量的命令，但是它提供了一个框架，您可以在其中插入许多特定于任务的命令ーー那些由可编写脚本的应用程序和 macOS 的可编写脚本的部分提供的命令。</p>\n<p>本指南中的大多数脚本示例和脚本片段都使用 Finder 应用程序的可脚本化特性、 macOS 的可脚本化部分，或者与 macOS 一起发布的可脚本化应用程序，例如 TextEdit (位于/Applications 中)。</p>\n<h2 id=\"2-applescript-词法约定\">2. AppleScript 词法约定</h2>\n<h3 id=\"21-character-set-字符集\">2.1 Character Set 字符集</h3>\n<blockquote>\n<p>从OS X v10.5（AppleScript 2.0）开始，AppleScript的字符集为Unicode。AppleScript在全球范围内正确保留所有字符，脚本中的注释和文本常量可以包含任何Unicode字符。</p>\n</blockquote>\n<p>AppleScript语法使用几个非ASCII字符，可以使用特殊的组合键键入这些字符。有关AppleScript特别处理的字符的信息，请参阅后续介绍</p>\n<h3 id=\"22-identfiers-标识符\">2.2 Identfiers 标识符</h3>\n<h3 id=\"23-命名规则\">2.3 命名规则</h3>\n<h4 id=\"231-标识符必须以字母开始，并且可以包含下列字符\">2.3.1 标识符必须以字母开始，并且可以包含下列字符</h4>\n<pre><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\n</code></pre>\n<h4 id=\"232-命名格式\">2.3.2 命名格式</h4>\n<blockquote>\n<p>AppleScript会记住并强制执行它遇到的标识符的第一个大写。因此，如果它首先遇到一个名为myAccount的标识符，它将在编译期间将myAccount和myAccount等版本更改为myAccount。</p>\n</blockquote>\n<p>有效标识符的示例： <code>areaOfCircle</code> 、 <code>Agent007</code> 、 <code>axis_of_rotation</code> 。</p>\n<p>无效的标识符：<code>0#</code>、<code>1#</code>、<code>2#</code>、<code>3#</code>。</p>\n<pre><code>AppleScript对上述规则提供了一个漏洞:第一个和最后一个字符是竖条的标识符(|)可以包含任何字符。前面和后面的垂直条不被认为是标识符的一部分。\n但是 使用竖线会使脚本难以阅读，不建议使用。\n合法的标识符： |back&amp;forth| 、 |Right*Now!| 。\n标识符可以包含附加的竖线，竖线前面有一个反斜杠（\\）字符，如标识符 |This\\|Or\\|That| \n</code></pre>\n<h3 id=\"24-关键字\">2.4 关键字</h3>\n<p>关键字是AppleScript语言中的保留字。关键字由小写字母组成:abcdefghijklmnopqrstuvwxyz。在一些情况下，比如aside，它们是成对出现的。</p>\n<p><strong><code>重要提示：您不应尝试在脚本中将关键字重复用于变量名或其他目的。开发人员不应在其脚本化应用程序的术语中重新定义关键字。</code></strong></p>\n<table>\n<thead>\n<tr>\n<th><code>about</code></th>\n<th><code>above</code></th>\n<th><code>after</code></th>\n<th><code>against</code></th>\n<th><code>and</code></th>\n<th><code>apart from</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>around</code></td>\n<td><code>as</code></td>\n<td><code>aside from</code></td>\n<td><code>at</code></td>\n<td><code>back</code></td>\n<td><code>before</code></td>\n</tr>\n<tr>\n<td><code>beginning</code></td>\n<td><code>behind</code></td>\n<td><code>below</code></td>\n<td><code>beneath</code></td>\n<td><code>beside</code></td>\n<td><code>between</code></td>\n</tr>\n<tr>\n<td><code>but</code></td>\n<td><code>by</code></td>\n<td><code>considering</code></td>\n<td><code>contain</code></td>\n<td><code>contains</code></td>\n<td><code>contains</code></td>\n</tr>\n<tr>\n<td><code>continue</code></td>\n<td><code>copy</code></td>\n<td><code>div</code></td>\n<td><code>does</code></td>\n<td><code>eighth</code></td>\n<td><code>else</code></td>\n</tr>\n<tr>\n<td><code>end</code></td>\n<td><code>equal</code></td>\n<td><code>equals</code></td>\n<td><code>error</code></td>\n<td><code>every</code></td>\n<td><code>exit</code></td>\n</tr>\n<tr>\n<td><code>false</code></td>\n<td><code>fifth</code></td>\n<td><code>first</code></td>\n<td><code>for</code></td>\n<td><code>fourth</code></td>\n<td><code>from</code></td>\n</tr>\n<tr>\n<td><code>front</code></td>\n<td><code>get</code></td>\n<td><code>given</code></td>\n<td><code>global</code></td>\n<td><code>if</code></td>\n<td><code>ignoring</code></td>\n</tr>\n<tr>\n<td><code>in</code></td>\n<td><code>instead of</code></td>\n<td><code>into</code></td>\n<td><code>is</code></td>\n<td><code>it</code></td>\n<td><code>its</code></td>\n</tr>\n<tr>\n<td><code>last</code></td>\n<td><code>local</code></td>\n<td><code>me</code></td>\n<td><code>middle</code></td>\n<td><code>mod</code></td>\n<td><code>my</code></td>\n</tr>\n<tr>\n<td><code>ninth</code></td>\n<td><code>not</code></td>\n<td><code>of</code></td>\n<td><code>on</code></td>\n<td><code>onto</code></td>\n<td><code>or</code></td>\n</tr>\n<tr>\n<td><code>out of</code></td>\n<td><code>over</code></td>\n<td><code>prop</code></td>\n<td><code>property</code></td>\n<td><code>put</code></td>\n<td><code>ref</code></td>\n</tr>\n<tr>\n<td><code>reference</code></td>\n<td><code>repeat</code></td>\n<td><code>return</code></td>\n<td><code>returning</code></td>\n<td><code>script</code></td>\n<td><code>second</code></td>\n</tr>\n<tr>\n<td><code>set</code></td>\n<td><code>seventh</code></td>\n<td><code>since</code></td>\n<td><code>sixth</code></td>\n<td><code>some</code></td>\n<td><code>tell</code></td>\n</tr>\n<tr>\n<td><code>tenth</code></td>\n<td><code>that</code></td>\n<td><code>the</code></td>\n<td><code>then</code></td>\n<td><code>third</code></td>\n<td><code>through</code></td>\n</tr>\n<tr>\n<td><code>thru</code></td>\n<td><code>timeout</code></td>\n<td><code>times</code></td>\n<td><code>to</code></td>\n<td><code>transaction</code></td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td><code>try</code></td>\n<td><code>until</code></td>\n<td><code>where</code></td>\n<td><code>while</code></td>\n<td><code>whose</code></td>\n<td><code>with</code></td>\n</tr>\n<tr>\n<td><code>without</code></td>\n<td>``</td>\n<td>``</td>\n<td>``</td>\n<td>``</td>\n<td>``</td>\n</tr>\n</tbody></table>\n<h3 id=\"25-注释\">2.5 注释</h3>\n<p>注释是在执行脚本时被AppleScript忽略的文本。你可以使用注释来描述脚本中发生的事情，或者做其他类型的笔记。注释有三种:</p>\n<h4 id=\"251-块注释\">2.5.1 块注释</h4>\n<p>注释块以字符**<code>(*</code><strong>开始,以字符</strong><code>*)</code>**结束。块注释必须放在其他语句之间。这意味着它们可以放在同一行，在语句的开始或结束处，但不能嵌入到简单的(一行)语句中。</p>\n<pre><code class=\"language-apl\">(*\n块注释\n*)\n</code></pre>\n<h4 id=\"252-行注释\">2.5.2 行注释</h4>\n<pre><code>-- 行注释\n</code></pre>\n<h4 id=\"253--行注释\">2.5.3 # 行注释</h4>\n<p>从版本2.0开始，AppleScript还支持使用#符号作为行尾注释。这样，你就可以把一个普通的AppleScript脚本变成Unix可执行文件，方法是像下面这样开始它，并赋予它执行权限</p>\n<pre><code class=\"language-apl\">#!/usr/bin/osascript\n</code></pre>\n<p>使用#的编译过的脚本在2.0版本之前的系统上可以正常运行，如果编辑过，则使用——显示。使用 #!/usr/bin/osascript 将无法在2.0之前的系统上运行，因为#将被视为语法错误。</p>\n<h3 id=\"26-the-continuation-character-延续性\">2.6 The Continuation Character 延续性</h3>\n<p>一个简单的AppleScript语句通常必须在一行中输入。您可以通过以继续字符¬结尾来将语句扩展到下一行。使用美式键盘时，您可以通过键入Option-l（小写字母L）来输入此字符。在脚本编辑器中，可以键入Option-Return，这将插入连续字符并将插入点移动到下一行。</p>\n<p>下面是显示在两行中的单个语句：</p>\n<pre><code>display dialog &quot;This is just a test.&quot; buttons {&quot;Great&quot;, &quot;OK&quot;} ¬\ndefault button &quot;OK&quot; giving up after 3\n</code></pre>\n<p>引用文本字符串中的连续字符与任何其他字符一样处理。</p>\n<h3 id=\"27-literals-and-constants-字面量和常量\">2.7 Literals and Constants 字面量和常量</h3>\n<blockquote>\n<p>字面量是一个计算结果为自身的值，，也就是说，它被写入时就会被解释。例如，在AppleScript中，“Hello”是文本字面量。常量是一个有预定义值的单词。例如，AppleScript定义了许多枚举的常量，用于path to (folder)命令，每个常量都指定了获取路径的位置</p>\n</blockquote>\n<h4 id=\"271-boolean-布尔型\">2.7.1 Boolean 布尔型</h4>\n<p>AppleScript定义布尔值 <code>true</code> 和 <code>false</code> ，并提供 <code>boolean</code> 类。</p>\n<h4 id=\"272-constant-常数\">2.7.2 Constant 常数</h4>\n<p>AppleScript中的全局常量描述了可在整个脚本中使用的常量。有关相关信息，请参见 <code>constant</code> 类。</p>\n<h4 id=\"273-list-列表\">2.7.3 List 列表</h4>\n<p>列表定义了一个有序的值集合，任何类的值都称为项。正如脚本中描述的那样，列表由一系列包含在花括号中的表达式组成，并用逗号分隔，如下所示</p>\n<pre><code class=\"language-apl\">{1, 7, &quot;Beethoven&quot;, 4.5}\n</code></pre>\n<ul>\n<li>列表可以包含其他列表；</li>\n<li>空列表(不包含任何元素)由一对空花括号表示:{}。</li>\n</ul>\n<p>AppleScript提供了用于处理列表的 <code>list</code> 类。</p>\n<h4 id=\"274-number-数值\">2.7.4 Number 数值</h4>\n<p>数值字面量是一个数字序列，可能包括其他字符，如一元减号、句点(实数)或“E+”(指数表示法)。下面是一些数字字面量。</p>\n<pre><code>-94596\n3.1415\n9.9999999999E+10\n</code></pre>\n<p>AppleScript定义了用于处理实数和整数值的类，以及number类，它是实数或整数的同义词。</p>\n<h4 id=\"275-record-记录\">2.7.5 Record 记录</h4>\n<p>记录是一组无序的标记属性的集合。记录在脚本中以一系列属性定义的形式出现，这些属性定义包含在大括号中，并用逗号分隔。每个属性定义由一个唯一的标签、一个冒号和属性值组成。例如，下面是一个具有两个属性的记录:</p>\n<pre><code class=\"language-apl\">{product:&quot;pen&quot;, price:2.34}\n</code></pre>\n<h4 id=\"276-文字\">2.7.6 文字</h4>\n<p>文本字面量由一系列用双引号括起来的Unicode字符组成，如下面的例子所示:</p>\n<pre><code>&quot;A basic string.&quot;\n</code></pre>\n<p>AppleScript text对象是text类的实例，text类提供了处理文本的机制。该类的Special String Characters部分描述了如何在文本中使用空格、反斜杠字符和双引号。</p>\n<h4 id=\"277-operators-操作符\">2.7.7 Operators 操作符</h4>\n<p>操作符是一个符号、单词或短语，可以从另一个值或值对派生出一个值。例如，乘法运算符(*)将两个数值操作数相乘，而连接运算符(&amp;)将两个对象(如文本字符串)连接起来。is equal操作符对两个布尔值进行测试。</p>\n<p>有关AppleScript运算符的详细信息，请参阅<code>Operators</code>参考</p>\n<h4 id=\"278-变量\">2.7.8 变量</h4>\n<p>变量是存储值的命名容器。它的名称是在创建变量时指定的，遵循标识符中描述的规则。使用copy或set命令可以同时声明和初始化变量。例如:</p>\n<pre><code class=\"language-apl\">set myName to &quot;John&quot;\ncopy 33 to myAge\n</code></pre>\n<p>给变量赋值的语句称为赋值语句</p>\n<p>当AppleScript遇到一个变量时，它通过获取它的值来求值。变量包含在脚本中，当你关闭包含它的脚本时，它的值通常会丢失。</p>\n<p>AppleScript变量可以保存任何类的值。例如，您可以将整数值 <code>17</code> 赋给变量，然后将布尔值 <code>true</code> 赋给同一变量。</p>\n<p>有关更多信息，请参见<a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_variables.html#//apple_ref/doc/uid/TP40000983-CH223-SW10\">Variables and Properties</a></p>\n<h4 id=\"279-expressions-表达式\">2.7.9 Expressions 表达式</h4>\n<p>表达式是任何有值的词法元素序列。在脚本中使用表达式来表示或派生值。最简单的表达式称为字面量表达式，是脚本中值的表示形式。更复杂的表达式通常由字面量、变量、操作符和对象说明符组合而成。</p>\n<ul>\n<li>运行脚本时，AppleScript会将表达式转换为值。这个过程被称为评估。例如，下面这个简单表达式的计算结果是21:</li>\n</ul>\n<pre><code class=\"language-apl\">3 * 7 --result: 21\n</code></pre>\n<ul>\n<li>对象说明符指定了查找另一个对象所需的部分或全部信息。例如，下面的对象说明符指定一个命名文档:</li>\n</ul>\n<pre><code class=\"language-apl\">document named &quot;FavoritesList&quot;\n</code></pre>\n<p>有关更多信息，请参见<a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html#//apple_ref/doc/uid/TP40000983-CH218-SW7\">Object Specifiers</a>。</p>\n<h4 id=\"2710-statements-语句\">2.7.10 Statements 语句</h4>\n<p>语句是一系列遵循特定AppleScript语法的词法元素。语句可以包含关键字、变量、运算符、常量、表达式等。</p>\n<p>每个脚本都由语句组成。当AppleScript执行脚本时，它按顺序读取语句并执行它们的指令。</p>\n<p>控制语句是确定何时以及如何执行其他语句的语句。AppleScript定义了标准的控制语句，如if、repeat和while语句，在 <a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_control_statements.html#//apple_ref/doc/uid/TP40000983-CH6g-157332\">Control Statements Reference</a>.中有详细描述。</p>\n<p>简单的语句可以写在一行中:</p>\n<pre><code class=\"language-apl\">set averageTemp to 63 as degrees Fahrenheit\n</code></pre>\n<p>复合语句写在多行上，可以包含其他语句，并且在最后一行有单词end(可选地跟在语句的第一个单词后面)。例如，下面是一个复合tell语句:</p>\n<pre><code class=\"language-apl\">tell application &quot;Finder&quot;\n    set savedName to name of front window\n    close window savedName\nend tell\n</code></pre>\n<p>复合语句可以包含其他复合语句。</p>\n<h4 id=\"2711-commands-命令\">2.7.11 Commands 命令</h4>\n<p>命令是AppleScript语句中用于请求操作的一个或一系列单词。每个命令都指向一个目标，目标是响应命令的对象。目标通常是一个应用程序对象或macOS中的对象，但它也可以是一个脚本对象或当前脚本中的值。</p>\n<p>以下语句使用AppleScript的 <a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/reference/ASLR_cmds.html#//apple_ref/doc/uid/TP40000983-CH216-SW56\">get</a> 命令获取窗口名称;目标是Finder应用程序的前窗口：</p>\n<pre><code class=\"language-apl\">get name of front window of application &quot;Finder&quot;\n</code></pre>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/2023%2F08%2F20%2F1b038e9bda84462488fea956b64529c4.png\" alt=\"image-20230820164851917\"  data-is-external-image=\"true\"></figure></p>\n<p>有关命令类型、参数和目标的详细信息，请参见 <a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html#//apple_ref/doc/uid/TP40000983-CH218-SW8\">Commands Overview</a></p>\n<h4 id=\"2712-results-结果\">2.7.12 Results 结果</h4>\n<p>语句的结果是执行语句时生成的值(如果有的话)。例如，执行语句3 + 4会得到值7。将myText设置为”keyboard”的语句返回的结果是文本对象”keyboard”。结果可以是任何类。AppleScript将结果存储在全局可用的属性result中，在<a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_fundamentals.html#//apple_ref/doc/uid/TP40000983-CH218-SW38\">AppleScript Constant</a>描述。 </p>\n<h4 id=\"2713-raw-codes-原始代码\">2.7.13 Raw Codes 原始代码</h4>\n<p>当您使用脚本编辑器打开、编译、编辑或运行脚本时，您可能偶尔会在一个脚本窗口或另一个窗口中看到包含在双尖括号或线形符号(«»)中的术语。这些术语称为原始格式(raw format)或原始代码(raw code)，因为它们表示底层的Apple事件代码，AppleScript使用这些代码表示脚本术语。</p>\n<p>为了兼容亚洲国家的编码，” “ “和” “ “被允许作为”«”和”»”的同义词((在美国键盘上，分别是Option- \\和Option- shift - )，因为后者在一些亚洲编码中不存在。</p>\n<p> For more information on raw codes, see <a href=\"https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/conceptual/ASLR_raw_data.html#//apple_ref/doc/uid/TP40000983-CH225-SW1\">Double Angle Brackets</a>.</p>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/35/2022-02-27-08.13.15-2782507757125630619_5823209264.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "develop"
            ],
            "date_published": "2023-08-20T16:52:59+08:00",
            "date_modified": "2023-08-20T16:55:05+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/emby48039/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/emby48039/",
            "title": "emby4.8.0.39 ",
            "summary": "1. 下载指定官方包 这里以群晖+系统7.2 X86为例 https://github.com/MediaBrowser/Emby.Releases/releases 群晖套件中心手动安装软件包 略过 停用emby 连接群晖SSH 使用切换到root权限,打开[/var/packages/EmbyServer/target/system]文件夹&hellip;",
            "content_html": "<h3 id=\"1-下载指定官方包\">1. 下载指定官方包</h3>\n<p>这里以群晖+系统7.2  X86为例</p>\n<p><a href=\"https://github.com/MediaBrowser/Emby.Releases/releases\">https://github.com/MediaBrowser/Emby.Releases/releases</a> </p>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202307141035374.png\" alt=\"image-20230714103519265\"  data-is-external-image=\"true\"></figure></p>\n<h3 id=\"2-手动安装软件包\">2. 手动安装软件包</h3>\n<p>群晖套件中心手动安装软件包 略过</p>\n<h3 id=\"3-破解\">3. 破解</h3>\n<ol>\n<li><p>停用emby</p>\n</li>\n<li><p>连接群晖SSH</p>\n</li>\n<li><p>使用切换到root权限,打开[/var/packages/EmbyServer/target/system]文件夹</p>\n</li>\n<li><p>创建文件run.sh ,写入内容如下:</p>\n<pre><code class=\"language-shell\">echo &quot;-------------------web 端开心-------------------&quot;\necho &quot;使用脚本前，请先进入到 emby 的 system 目录下&quot;\necho &quot;官方包直接安装的路径为：cd /opt/emby-server/system/&quot;\necho &quot;&quot;\necho &quot;docker 安装请自己找路径进入再执行&quot;\necho &quot;-------------------我们的域名：https://hexsen.com-------------------&quot;\nrm -f Emby.Web.dll\nwget  https://service.hexsen.com/emby/crack39/Emby.Web.dll\nchmod 777 Emby.Web.dll\nrm -f MediaBrowser.Model.dll\nwget   https://service.hexsen.com/emby/crack39/MediaBrowser.Model.dll\nchmod 777 MediaBrowser.Model.dll\necho &quot;核心开心完成...&quot;lient/\ncd dashboard-ui/embypremiere/\nrm -f embypremiere.js\nwget   https://service.hexsen.com/emby/crack39/dashboard-ui/embypremiere/embypremiere.js\nchmod 777 embypremiere.js\necho &quot;web 开心完成...&quot;\ncd ../../\nrm -f Emby.Server.Implementations.dll\nwget   https://service.hexsen.com/emby/crack39/Emby.Server.Implementations.dll\nchmod 777 Emby.Server.Implementations.dll\necho &quot;Implementations 替换认证...&quot;\n</code></pre>\n</li>\n</ol>\n<p>5.运行run.sh </p>\n<pre><code class=\"language-shell\">bash run.sh\n</code></pre>\n<p>6.等待运行结束,启动emby,如果没有图标显示清楚缓存刷新一次</p>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/33/IMG_9807.png",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "common"
            ],
            "date_published": "2023-07-14T10:44:43+08:00",
            "date_modified": "2023-07-14T13:35:01+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/ju-he-yin-le-xia-zai/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/ju-he-yin-le-xia-zai/",
            "title": "聚合音乐下载",
            "summary": "项目地址 : https://github.com/0xHJK/music-dl $ pip3 install pymusic-dl 1.2 手动安装（最新）： $&hellip;",
            "content_html": "<p>项目地址 : <a href=\"https://github.com/0xHJK/music-dl\">https://github.com/0xHJK/music-dl</a></p>\n<h3 id=\"1-安装方式\">1. 安装方式</h3>\n<h4 id=\"11-pip安装（推荐，注意前面有一个py）：\">1.1 pip安装（推荐，注意前面有一个<code>py</code>）：</h4>\n<pre><code>$ pip3 install pymusic-dl\n</code></pre>\n<h4 id=\"12-手动安装（最新）：\">1.2 手动安装（最新）：</h4>\n<pre><code>$ git clone https://github.com/0xHJK/music-dl.git\n$ cd music-dl\n$ python3 setup.py install\n</code></pre>\n<h4 id=\"13-不安装直接运行：\">1.3 不安装直接运行：</h4>\n<pre><code>$ git clone https://github.com/0xHJK/music-dl.git\n$ cd music-dl\n$ pip3 install -r requirements.txt\n$ ./music-dl\n\n# 或 python3 music-dl\n</code></pre>\n<h3 id=\"2-使用方法\">2. 使用方法</h3>\n<pre><code class=\"language-shell\">$ music-dl --help\nUsage: music-dl [OPTIONS]\n\n  Search and download music from netease, qq, kugou, baidu and xiami.\n  Example: music-dl -k &quot;周杰伦&quot;\n\nOptions:\n  --version             Show the version and exit.\n  -k, --keyword TEXT    搜索关键字，歌名和歌手同时输入可以提高匹配（如 空帆船 朴树）\n  -u, --url TEXT        通过指定的歌曲URL下载音乐\n  -p, --playlist TEXT   通过指定的歌单URL下载音乐\n  -s, --source TEXT     Supported music source: qq netease kugou baidu\n  -n, --number INTEGER  Number of search results\n  -o, --outdir TEXT     Output directory\n  -x, --proxy TEXT      Proxy (e.g. http://127.0.0.1:1087)\n  -v, --verbose         Verbose mode\n  --lyrics              同时下载歌词\n  --cover               同时下载封面\n  --nomerge             不对搜索结果列表排序和去重\n  --help                Show this message and exit.\n</code></pre>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202306291213398.png\" alt=\"image-20230629121326813\"  data-is-external-image=\"true\"></figure></p>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/32/NIMURA-tribute-to-NIRVANA.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
            ],
            "date_published": "2023-06-29T16:04:14+08:00",
            "date_modified": "2023-07-11T19:48:31+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/publii-jing-tai-ye-mian-jia-mi/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/publii-jing-tai-ye-mian-jia-mi/",
            "title": "publii 静态页面加密",
            "summary": "publii目前暂不支持单篇文章加密，使用密码访问文章的功能。 开发者推荐隐藏文章，然后使用私有的链接访问，这种方式很不方便. 理想状态应该是页面正常渲染在主页 ，我可以对指定文章加密，并设置密码。寻找了几个开源的静态网页加密工具。 Domain:https://github.com/Li4n0/hugo_encryptor 演示效果:https://0n0.fun/post/2019/03/this-is-hugo-encryptor/ 类似的工具:https://github.com/D0n9X1n/hexo-blog-encrypt 简介: Hugo-Encryptor 是一款能够帮助作者保护文章内容的工具。它使用&hellip;",
            "content_html": "<blockquote>\n<p> <code>publii</code>目前暂不支持单篇文章加密，使用密码访问文章的功能。 开发者推荐隐藏文章，然后使用私有的链接访问，这种方式很不方便. 理想状态应该是页面正常渲染在主页 ，我可以对指定文章加密，并设置密码。寻找了几个开源的静态网页加密工具。</p>\n</blockquote>\n<h2 id=\"1-hugo-encryptor\">1. Hugo Encryptor</h2>\n<ul>\n<li><p>Domain:<a href=\"https://github.com/Li4n0/hugo_encryptor\">https://github.com/Li4n0/hugo_encryptor</a></p>\n</li>\n<li><p>演示效果:<a href=\"https://0n0.fun/post/2019/03/this-is-hugo-encryptor/\">https://0n0.fun/post/2019/03/this-is-hugo-encryptor/</a></p>\n</li>\n<li><p>类似的工具:<a href=\"https://github.com/D0n9X1n/hexo-blog-encrypt\">https://github.com/D0n9X1n/hexo-blog-encrypt</a></p>\n</li>\n</ul>\n<blockquote>\n<p>简介: <strong>Hugo-Encryptor</strong> 是一款能够帮助作者保护文章内容的工具。它使用 AES-256 来对文章的内容进行加密，并且通过在文章中嵌入内联 <code>JavaScript</code> 代码来验证读者输入的密码是否正确。没有正确的文章密码，读者将无法看到文章的加密内容。</p>\n</blockquote>\n<p><code>优点是可以加密文章指定内容</code></p>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202304121104007.png\" alt=\"image-20230412110404943\"  data-is-external-image=\"true\"></figure></p>\n<h2 id=\"2-pagecrypt\">2. pagecrypt</h2>\n<ul>\n<li><p>Domain:<a href=\"https://github.com/MaxLaumeister/pagecrypt/tree/master/python\">https://github.com/MaxLaumeister/pagecrypt/tree/master/python</a></p>\n</li>\n<li><p>演示效果:<a href=\"https://www.maxlaumeister.com/pagecrypt/\">https://www.maxlaumeister.com/pagecrypt/</a></p>\n</li>\n<li><p>介绍页:<a href=\"https://render.com/blog/static-site-auth-pagecrypt\">https://render.com/blog/static-site-auth-pagecrypt</a></p>\n</li>\n<li><p>类似的工具:<a href=\"https://github.com/robinmoisson/staticrypt\">https://github.com/robinmoisson/staticrypt</a></p>\n</li>\n</ul>\n<blockquote>\n<p>简介:<a href=\"https://github.com/Greenheart/pagecrypt\">PageCrypt</a>是一种新颖的密码保护解决方案，无需后端即可保护 HTML。它是一个库，您可以将其用作站点构建步骤的一部分或用作命令行工具。它使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API\">Web Crypto API</a>（目前<a href=\"https://caniuse.com/cryptography\">所有主要浏览器都支持</a>）和密码来加密 HTML 页面，然后您可以在任何静态托管平台上托管该页面，包括 Render！使用 PageCrypt 加密的 HTML 页面会提示查看者输入密码。输入正确的密码后，页面将被解密，其内容将替换密码提示</p>\n</blockquote>\n<p><code>貌似只能对整个页面加密</code></p>\n<h2 id=\"image-20230412110543963\"><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202304121120566.png\" alt=\"image-20230412110543963\"  data-is-external-image=\"true\"></figure></h2>\n<h2 id=\"3-staticshield-docs\">3. staticshield-docs</h2>\n<ul>\n<li>Domain:<a href=\"https://github.com/lalit2005/staticshield\">https://github.com/lalit2005/staticshield</a></li>\n</ul>\n<blockquote>\n<p> StaticShield 是<strong>密码保护网站的最简单方法</strong>。无论是静态的还是动态的，您只需要一行代码就可以保护您的应用程序。真的吗！！只需要<strong>一行代码</strong><code>head</code>的文件！StaticShield 可以轻松地与您选择的任何喜欢的框架一起使用。无论是优秀的 HTML 还是现代的 Nextjs，一切都像魔术一样工作。您可以为用户设置过期时间，以便在一段时间后自动注销，或者您可以在任何给定时间点以编程方式注销用户。哦，我怎么忘了这个 - 安全。由于 StaticShield 必须处理保护敏感内容的问题，因此我将安全放在首位。我采取了一些安全措施，我既没有看到也没有听说过有人对他们的应用程序这样做。阅读更多以找出答案！我想这介绍太多了，让我们深入了解</p>\n</blockquote>\n<p><code>staticshield 会同时提供一个管理页面,查看通过密码访问的次数</code></p>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202304121113024.png\" alt=\"image-20230412111336987\"  data-is-external-image=\"true\"></figure></p>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202304121114469.png\" alt=\"image-20230412111453438\"  data-is-external-image=\"true\"></figure></p>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/30/kurinkohunoTVCMnoirasutowoDan-Dang-saseteitatakimasita.-Jiu-Zhou-Zhong-Guo-Si-Guo-eriaYi-Bu-woChu-kuteBen-Ri-karaFang-Ying-sareteirutonokoto.-Pu-noirasutowomotonianimetasan.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "develop"
            ],
            "date_published": "2023-04-12T11:16:10+08:00",
            "date_modified": "2023-06-28T10:27:25+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/chengdu_to_xichang/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/chengdu_to_xichang/",
            "title": "成都 -&gt; 西昌两日",
            "summary": "从去年成都到西昌的高铁通车后, 一直计划着去西昌晒晒太阳, 终于最近周末有空了 ... 成都出发 成都南站 -&gt;&gt; 西昌高铁站 费用 1人/136元&hellip;",
            "content_html": "<noscript>\n\t<meta http-equiv='refresh' content='0' url='https://bit.ly/ss-noscript' />\n</noscript><noscript>\n\t<meta http-equiv='refresh' content='0' url='https://bit.ly/ss-noscript' />\n</noscript>\n<blockquote>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">从去年成都到西昌的高铁通车后, 一直计划着去西昌晒晒太阳, 终于最近周末有空了 ...</span></p>\n</blockquote>\n<div class=\"post__toc\">\n<h3>目录</h3>\n<ul>\n<li><a href=\"#mcetoc_1gsounc0258\">交通</a></li>\n<li><a href=\"#mcetoc_1gsounc0259\">饮食</a></li>\n<li><a href=\"#mcetoc_1gsounc025a\">住宿</a></li>\n<li><a href=\"#mcetoc_1gsounc025b\">注意事项</a></li>\n<li><a href=\"#mcetoc_1gsourgmq5e\">照片</a></li>\n</ul>\n</div>\n<h3 id=\"mcetoc_1gsounc0258\" class=\"md-end-block md-heading\"><span class=\"md-plain\"><br>交通</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">成都出发 </span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">成都南站</span></strong></span><span class=\"md-plain\"> -&gt;&gt; </span><span class=\"md-pair-s \"><strong><span class=\"md-plain\">西昌高铁站</span></strong></span><span class=\"md-plain\">  费用 1人/136元</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">到西昌后,可以选择公交车(上下车都需要打卡)/出租车</span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\"> 费用 </span></p>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">公交车 1人/2-8元 ,有专用车道</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">出租车打表,但是西昌交通不太通畅&amp;红绿灯路口多,十公里路程能走1小时左右,车费在45左右,推荐公交车</span></p>\n</li>\n</ul>\n<h3 id=\"mcetoc_1gsounc0259\" class=\"md-end-block md-heading md-focus\"><span class=\"md-plain\">饮食</span></h3>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">西昌火盆烤肉 <br><br>比较失望</span> <span class=\"md-plain\">一直最期待的就是西昌的烤肉 ,结果吃了 [陈小肠火盆烤肉] 后, 我们由本来的三天计划,立即缩减到两天,迅速修改行程重新订票 😂, 味道一般,且菜品卫生堪忧</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">卷粉 这个不错挺好吃 </span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">凉粉 这个经常吃到,味道一般</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">米粉 这个不错,推荐<br></span>   </p>\n</li>\n<li>网红炸串店\"怪难吃\",我的建议是没必要去😄</li>\n</ul>\n<h3 id=\"mcetoc_1gsounc025a\" class=\"md-end-block md-heading\"><span class=\"md-plain\">住宿</span></h3>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">我们这次是在邛海17°这边住着,但是我们转了一圈考察了下 ,住在大石板村这边也挺不错<br></span></p>\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">推荐住宿位置:</span></p>\n<ol>\n<li>邛海17°附近,在市区周围出行,购物相对方便</li>\n<li>大石板村, 距离邛海公园,灵鹰寺很近,本身也是西昌的一个古村.</li>\n</ol>\n<h3 id=\"mcetoc_1gsounc025b\" class=\"md-end-block md-heading\"><span class=\"md-plain md-expand\">注意事项</span></h3>\n<ul class=\"ul-list\" data-mark=\"-\">\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">阳光很足... 注意防晒</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">金鳞沙滩就是小孩玩的沙盘,很袖珍</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">唐园和建昌古城晚上去挺好看</span></p>\n</li>\n<li class=\"md-list-item\">\n<p class=\"md-end-block md-p\"><span class=\"md-plain\">泸山比较小,排队一小时索道五分钟</span></p>\n</li>\n</ul>\n<h3 id=\"mcetoc_1gsourgmq5e\">照片</h3>\n<div class=\"gallery-wrapper gallery-wrapper--wide\"><div class=\"gallery\"  data-is-empty=\"false\" data-translation=\"添加图片\" data-columns=\"3\">\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9888.jpeg\" data-size=\"2095x1178\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9888-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>邛海公园</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0049.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0049-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>邛海公园</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9901.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9901-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>泸山</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9929.jpeg\" data-size=\"2268x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9929-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>泸山猴子</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9946.jpeg\" data-size=\"3024x4032\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9946-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1024\"></a>\n<figcaption>泸山猴子</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0030.jpeg\" data-size=\"6100x3490\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0030-thumbnail.webp\" alt=\"\" width=\"768\" height=\"439\"></a>\n<figcaption>唐园</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0075.jpeg\" data-size=\"3540x6294\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0075-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>灵鹰寺侧面</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0064.jpeg\" data-size=\"3878x6894\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0064-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>灵鹰寺一角</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0078.jpeg\" data-size=\"3265x1836\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0078-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>灵鹰寺</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0063.jpeg\" data-size=\"3932x6990\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_0063-thumbnail.webp\" alt=\"\" width=\"768\" height=\"1365\"></a>\n<figcaption>灵鹰寺侧面</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9976.jpeg\" data-size=\"7922x4456\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9976-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>建昌古城</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9959.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9959-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>建昌古城</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9954.jpeg\" data-size=\"3315x1865\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9954-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>建昌古城</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9431.jpeg\" data-size=\"4032x2268\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28//gallery/IMG_9431-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>\"怪难吃\"炸串</figcaption>\n</figure>\n<figure class=\"gallery__item\"><a href=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28/gallery/IMG_0041.jpeg\" data-size=\"8064x4536\"><img decoding=\"async\" loading=\"lazy\" src=\"https://ct-choochoo.github.io/ch-publii-pages/media/posts/28/gallery/IMG_0041-thumbnail.webp\" alt=\"\" width=\"768\" height=\"432\"></a>\n<figcaption>米粉</figcaption>\n</figure>\n</div></div>\n<p class=\"md-end-block md-p\"> </p>",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/28/milan.deyy-Photo-shared-by-KitBash3D-on-December-04-2021-tagging-mi.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "real",
                   "outing"
            ],
            "date_published": "2023-03-30T00:20:45+08:00",
            "date_modified": "2023-07-11T09:09:30+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/rabbitmq-2/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/rabbitmq-2/",
            "title": "RabbitMQ-2",
            "summary": "好记性不如烂笔头,从这里开始,构建一个简易的外卖流程实际使用rabbitMQ // exchangeDeclare(交换机名称，路由类型（dirct，fanout，topic），是否持久化，是否自动删除，其他参数) channel.exchangeDeclare( exchangeName, BuiltinExchangeType.FANOUT, true, false, null); 2.2&hellip;",
            "content_html": "<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303292331625.png\" alt=\"\"  data-is-external-image=\"true\"></figure></p>\n<blockquote>\n<p><em>好记性不如烂笔头</em>,从这里开始,构建一个简易的外卖流程实际使用rabbitMQ</p>\n</blockquote>\n<h2 id=\"1-需求分析与架构设计\">1. 需求分析与架构设计</h2>\n<h3 id=\"11-项目设计要点\">1.1 项目设计要点</h3>\n<ul>\n<li>用微服务系统，组件之间充分解耦</li>\n<li>使用消息中间件，解耦业务逻辑</li>\n<li>使用数据库，持久化业务数据</li>\n</ul>\n<h3 id=\"12-什么是微服务架构\">1.2 什么是微服务架构</h3>\n<ul>\n<li>将应用程序构建为松耦合、可独立部署的一组服务</li>\n<li>服务：一个单一的、可独立部署的软件组件，实现了一些有用的功能</li>\n<li>松耦合：封装服务的实现细节，通过API调用</li>\n</ul>\n<h3 id=\"13-如何拆分微服务\">1.3 如何拆分微服务</h3>\n<ul>\n<li>根据系统操作进行微服务拆分</li>\n<li>根据业务能力进行微服务拆分 （推荐）</li>\n<li>根据子域进行微服务拆分</li>\n</ul>\n<h3 id=\"14-根据业务能力拆分\">1.4 根据业务能力拆分</h3>\n<ul>\n<li>订单获取和履行 → 订单微服务</li>\n<li>供应商和产品管理 → 商家微服务</li>\n<li>送餐，骑手管理 → 骑手微服务</li>\n<li>记账与结算 → 结算微服务</li>\n<li>积分管理 → 积分微服务</li>\n</ul>\n<h3 id=\"15微服务的数据库设计原则\">1.5微服务的数据库设计原则</h3>\n<ul>\n<li>每个微服务使用自己的数据库 </li>\n<li>不要使用共享数据库的方式进行通信 </li>\n<li>不要使用外键，对于数据量非常少的表慎用索引</li>\n</ul>\n<h2 id=\"2如何配置rabbitmq\">2.如何配置RabbitMQ</h2>\n<h3 id=\"21-新建exchange\">2.1 新建Exchange</h3>\n<pre><code class=\"language-java\">//    exchangeDeclare(交换机名称，路由类型（dirct，fanout，topic），是否持久化，是否自动删除，其他参数)   \nchannel.exchangeDeclare(\n          exchangeName, \n          BuiltinExchangeType.FANOUT, \n          true, \n          false, \n          null);\n</code></pre>\n<h3 id=\"22-新建queue\">2.2 新建Queue</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\n//   queueDeclare(队列名称，是否持久化，是否独占队列，是否自动删除，其他参数)\nchannel.queueDeclare(\n          queueName, \n          true, \n          false, \n          false, \n          null);\n</code></pre>\n<h3 id=\"23-绑定exchange和queue\">2.3 绑定Exchange和Queue</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\n//   queueBind（队列名称，路由器名称，路由键）    \nchannel.queueBind(\n          queueName, \n          exchangeName, \n          routingKey);\n</code></pre>\n<h2 id=\"3生产者如何发送消息\">3.生产者如何发送消息</h2>\n<h3 id=\"31-新建connectionfactory\">3.1 新建ConnectionFactory</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.ConnectionFactory;\n\n        CachingConnectionFactory connectionFactory = new CachingConnectionFactory();\n//  设置rabbitMQ host\n    connectionFactory.setHost(&quot;127.0.0.1&quot;);\n//\t设置端口\n    connectionFactory.setPort(5672);\n//\t设置用户名，密码\n    connectionFactory.setPassword(&quot;admin&quot;);\n    connectionFactory.setUsername(&quot;admin&quot;);\n</code></pre>\n<h3 id=\"32-获取connection并创建channel\">3.2 获取Connection并创建channel</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\n//jdk7 加入 try—resource  使用完自动关闭连接\ntry (Connection connection = connectionFactory.newConnection();\n Channel channel = connection.createChannel()) {\n//业务逻辑\n}\n</code></pre>\n<h3 id=\"33-使用basicpublish发送消息\">3.3 使用basicPublish发送消息</h3>\n<pre><code class=\"language-java\">import com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n// basicPublish（路由名称，路由键，其他参数，消息体（byte[]））\nchannel.basicPublish(\n              &quot;exchange.settlement.order&quot;, &quot;key.order&quot;, null, messageToSend.getBytes());\n</code></pre>\n<h2 id=\"4消费者如何消费消息\">4.消费者如何消费消息</h2>\n<h3 id=\"41-配置线程池\">4.1 配置线程池</h3>\n<p><strong>当项目中使用到异步时，哪怕是知道是有限线程也最好使用线程池去调度！</strong></p>\n<pre><code class=\"language-java\">package com.boo.rabbitmq.settlement.config;\n\nimport java.util.concurrent.Executor;\nimport org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.AsyncConfigurer;\nimport org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\n/**\n * 异步任务配置\n *\n * @author gaobo\n * @date 2022/03/18\n */\n@Configuration\n@EnableAsync\npublic class AsyncTaskConfig implements AsyncConfigurer {\n\n  // ThreadPoolTaskExecutor的处理流程\n  // 当池子大小小于corePoolSize，就新建线程，并处理请求\n  // 当池子大小等于corePoolSize，把请求放入workQueue中，池子里的空闲线程就去workQueue中取任务并处理\n  // 当workQueue放不下任务时，就新建线程入池，并处理请求，如果池子大小撑到了maximumPoolSize，就用RejectedExecutionHandler来做拒绝处理\n  // 当池子的线程数大于corePoolSize时，多余的线程会等待keepAliveTime长时间，如果无请求可处理就自行销毁\n\n  @Override\n  @Bean\n  public Executor getAsyncExecutor() {\n    ThreadPoolTaskExecutor threadPool = new ThreadPoolTaskExecutor();\n    // 设置核心线程数\n    threadPool.setCorePoolSize(10);\n    // 设置最大线程数\n    threadPool.setMaxPoolSize(100);\n    // 线程池所使用的缓冲队列\n    threadPool.setQueueCapacity(10);\n    // 等待任务在关机时完成--表明等待所有线程执行完\n    threadPool.setWaitForTasksToCompleteOnShutdown(true);\n    // 等待时间 （默认为0，此时立即停止），并没等待xx秒后强制停止\n    threadPool.setAwaitTerminationSeconds(60);\n    //  线程名称前缀\n    threadPool.setThreadNamePrefix(&quot;Rabbit-Async-&quot;);\n    // 初始化线程\n    threadPool.initialize();\n    return threadPool;\n  }\n\n  @Override\n  public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n    return null;\n  }\n}\n</code></pre>\n<h3 id=\"42-定义回调函数\">4.2 定义回调函数</h3>\n<pre><code class=\"language-java\">\n// 定义回调执行，消费者会监听一个队列，来消息时会调用这里的逻辑\nDeliverCallback deliverCallback = (consumerTag, message) -&gt; {\n//业务逻辑\n};\n</code></pre>\n<h3 id=\"43-使用basicconsumer消费消息\">4.3 使用basicConsumer消费消息</h3>\n<pre><code class=\"language-java\">\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\n\nchannel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; {});\n</code></pre>\n<h3 id=\"44-使用线程池启动basicconsumer\">4.4 使用线程池启动basicConsumer</h3>\n<pre><code class=\"language-java\">package com.boo.rabbitmq.settlement.config;\n\nimport com.boo.rabbitmq.settlement.service.SettlementMessageService;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * rabbit配置 spring启动时加载执行 orderMessageService.handleMessage()\n *\n * @author gaobo\n * @date 2022/03/18\n */\n@Slf4j\n@Configuration\npublic class RabbitConfig {\n  @Autowired SettlementMessageService messageService;\n    // spring初始化时会执行 @Configuration 注解类的 @Autowired注解的方法\n  @Autowired\n  public void startListenMessage() throws InterruptedException {\n    messageService.handleMessage();\n  }\n}\n</code></pre>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/27/Love.Death.and.Robots.S03E01.2022.AAC5.1.NF.HD1080P.Guan-Fang-Zhong-Zi.mp4_20220523_195304.079.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "java",
                   "develop",
                   "common"
            ],
            "date_published": "2023-03-29T23:32:43+08:00",
            "date_modified": "2023-07-11T10:52:58+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/rabbit-mq-1/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/rabbit-mq-1/",
            "title": "RabbitMQ - 1",
            "summary": "MQ 简介（message queue） 从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖&hellip;",
            "content_html": "<h2 id=\"mq-简介（message-queue）\">MQ 简介（message queue）</h2>\n<blockquote>\n<p>从字面意思上看，本质是个队列，<strong>FIFO</strong> 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不 用依赖其他服务。</p>\n</blockquote>\n<h2 id=\"mq-优缺点\">MQ 优缺点</h2>\n<h4 id=\"优点\"><strong>优点</strong></h4>\n<ol>\n<li><p><strong>解耦</strong>：提升系统容错性</p>\n<pre><code>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\n</code></pre>\n</li>\n<li><p>异步提速：提升用户体验和吞吐量</p>\n<pre><code>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。\n</code></pre>\n</li>\n<li><p>削峰添谷：提高系统稳定性</p>\n<pre><code>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\n</code></pre>\n</li>\n</ol>\n<h4 id=\"缺点\">缺点</h4>\n<ol>\n<li><strong>提高系统复杂性</strong></li>\n<li><strong>系统可用性降低</strong></li>\n</ol>\n<h2 id=\"常用消息队列对比\">常用消息队列对比</h2>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291459041.png\" alt=\"image.png\"  data-is-external-image=\"true\"></figure></p>\n<hr>\n<h2 id=\"amqp-协议\">AMQP 协议</h2>\n<blockquote>\n<p>AMQP协议作为RabbitMQ的规范，规定了RabbitMQ对外接口，学会了AMQP协议的使用，就基本掌握了RabbitMQ的使用，学会了AMQP协议的概念，就基本掌握了RabbitMQ的核心概念</p>\n</blockquote>\n<h3 id=\"amqp协议的作用\">AMQP协议的作用</h3>\n<ul>\n<li>AMQP 是一个协议，规定了软件之间的行为</li>\n<li>RabbitMQ 是AMQP协议的具体实现</li>\n<li>AMQP协议还有其他实现，如RocketMQ等</li>\n</ul>\n<h3 id=\"amqp协议中的概念\">AMQP协议中的概念</h3>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291459220.png\" alt=\"image.png\"  data-is-external-image=\"true\"></figure></p>\n<ul>\n<li>Broker: 接收和分发消息的应用，RabbitMQ 就是Message Broker</li>\n<li>Virtual Host: 虚拟Broker，将多个单元隔离开</li>\n<li>Connection: publisher／consumer和broker之间的TCP连接</li>\n<li>Channel: connection内部建立的逻辑连接，通常每个线程创建单独的channel</li>\n<li>Routing Key: 路由键，用来指示消息的路由转发，相当于快递的地址</li>\n<li>Exchange: 交换机，相当于快递的分拨中心，是AMQP中的核心概念</li>\n<li>Queue: 消息队列，消息最终被送到这里等待consumer取走</li>\n<li>Binding: exchange和queue之间的虚拟连接，用于message的分发依据</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n<th>关系</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Broker</td>\n<td>消息队列服务器，负责接收、存储和传递消息</td>\n<td>包含多个 Virtual Host</td>\n</tr>\n<tr>\n<td>Virtual Host</td>\n<td>AMQP 中的逻辑隔离单元，一个 Virtual Host 可以包含多个 Exchange 和 Queue</td>\n<td>包含多个 Exchange 和 Queue；一个 Connection 可以连接至一个特定的 Virtual Host</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>应用程序与 Broker 之间建立的连接通道，用于发送、接收和管理消息</td>\n<td>可以连接至多个 Virtual Host；可以建立多个 Channel</td>\n</tr>\n<tr>\n<td>Channel</td>\n<td>建立在 Connection 之上的虚拟通道，用于在应用程序和 Broker 之间进行消息传递</td>\n<td>可以建立在一个 Connection 之上；每个 Channel 可以独立运作，支持消息的并行处理</td>\n</tr>\n<tr>\n<td>Routing Key</td>\n<td>消息的路由键，在消息发送时被用于匹配 Exchange 和 Queue，从而将消息路由到相应的队列中</td>\n<td>用于在 Exchange 和 Queue 之间建立关联关系</td>\n</tr>\n<tr>\n<td>Exchange</td>\n<td>接收和转发消息的对象，根据 Routing Key 将消息路由到相应的 Queue 中</td>\n<td>可以有不同的类型，包括 Direct、Topic、Fanout 等；可以与多个 Queue 建立 Binding</td>\n</tr>\n<tr>\n<td>Queue</td>\n<td>接收和存储消息的对象，通过 Exchange 路由到消息并进行存储</td>\n<td>可以与多个 Exchange 建立 Binding</td>\n</tr>\n<tr>\n<td>Binding</td>\n<td>Exchange 和 Queue 之间的关联关系，用于将消息从 Exchange 路由到对应的 Queue 中</td>\n<td>维护 Exchange 和 Queue 之间的关联关系</td>\n</tr>\n</tbody></table>\n<h3 id=\"\"></h3>\n<h3 id=\"amqp执行流程\">AMQP执行流程</h3>\n<ol>\n<li>消息的生产者连接到 Virtual Host，也就是虚拟主机。</li>\n<li>生产者创建 Connection，即连接到 Broker，也就是消息代理服务器。</li>\n<li>在 Connection 内创建 Channel，即消息通道，用来发送和接收消息。</li>\n<li>生产者将消息通过 Channel 发送给 Exchange，Exchange 是用来将消息路由到一个或多个队列的组件。</li>\n<li>生产者需要指定 Routing Key。Routing Key 用来指定消息应该被路由到哪些队列。</li>\n<li>Exchange 根据 Routing Key 和 Binding 来确定消息应该被路由到哪些队列。</li>\n<li>消息被路由到队列后，消费者可以连接到队列并接收消息。</li>\n<li>消费者也需要创建 Connection 和 Channel。</li>\n<li>消费者连接到队列并创建 Binding，Binding 是将 Exchange 和队列之间的关联声明。</li>\n<li>当有新消息进入队列，队列将自动将消息推送给绑定到该队列的消费者。</li>\n<li>消费者接收并处理消息，完成消息的消费流程。</li>\n</ol>\n<p><strong>总结：在AMQP协议中，生产者通过Connection和Channel将消息发送到Exchange，Exchange根据Routing Key和Binding规则将消息路由到相应的Queue。消费者通过Connection和Channel订阅Queue，并在消息到达时接收和处理消息。</strong></p>\n<p><strong>这种消息传递机制确保了生产者和消费者之间的松耦合，同时提供了高可扩展性和可靠性。在实际应用中，可以根据具体需求调整Exchange类型、Routing Key和Binding规则，实现多种复杂的消息路由策略。</strong></p>\n<h3 id=\"amqp协议的核心概念-exchange\">AMQP协议的核心概念-Exchange</h3>\n<ul>\n<li>在AMQP协议或者是RabbitMQ实现中，最核心的组件是Exchange</li>\n<li>Exchange承担RabbitMQ的核心功能——路由转发</li>\n<li>Exchange有多个种类，配置多变</li>\n</ul>\n<hr>\n<h2 id=\"exchange-介绍\">Exchange 介绍</h2>\n<h3 id=\"exchange\">Exchange</h3>\n<ul>\n<li>Exchange是AMQP协议和RabbitMQ的核心组件</li>\n<li>Exchange的功能是根据绑定关系和路由键为消息提供路由，将消息转发至相应的队列</li>\n<li>Exchange有4种类型：Direct / Topic / Fanout / Headers，其中Headers使用很少，以前三种为主</li>\n</ul>\n<h3 id=\"exchange-direct\">Exchange-Direct</h3>\n<blockquote>\n<p>Message中的Routing Key如果和Binding Key一致， Direct Exchange则将message发到对应的 queue中</p>\n</blockquote>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291459618.png\" alt=\"image.png\"  data-is-external-image=\"true\"></figure></p>\n<h3 id=\"exchange-fanout\">Exchange-Fanout</h3>\n<blockquote>\n<p>每个发到Fanout Exchange的message都会分发到所有绑定的queue上去</p>\n</blockquote>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291111603.png\" alt=\"image.png\"  data-is-external-image=\"true\"></figure></p>\n<h3 id=\"exchange-topic\">Exchange-Topic</h3>\n<ul>\n<li>根据Routing Key及通配规则，Topic Exchange将消息分发到目标Queue中全匹配：与Direct类似</li>\n<li>Binding Key中的#:匹配任意个数的word</li>\n<li>Binding Key中的*:匹配任意1个word</li>\n</ul>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291459408.png\" alt=\"image.png\"  data-is-external-image=\"true\"></figure></p>\n<h3 id=\"4rabbitmq安装-（docker）\">4.RabbitMQ安装 （docker）</h3>\n<pre><code class=\"language-shell\">docker run \n-p 1883:1883 \\\n-p 4369:4369 \\\n-p 5671:5671 \\\n-p 5672:5672 \\\n-p 8883:8883 \\\n-p 15672:15672 \n-p 25672:25672 \\\n-p 15675:15675 \\\n-d \\\n--hostname my-rabbitmq \\\n--name rabbitmq1 \\\n-e RABBITMQ_DEFAULT_USER=admin \\\n-e RABBITMQ_DEFAULT_PASS=admin \\\nrabbitmq:3.8.3\n\n\n#进入容器\ndocker exec -it name /bin/bash\n\n#启用管理控制台插件\nrabbitmq-plugins enable rabbitmq_management  管理控制台的默认端口是15672\n\n#启用mqtt插件\nrabbitmq-plugins enable rabbitmq_mqtt        默认端口mqtt是1883 mqtt://118.24.2.2:1883\n\n#启用mqtt插件的websocket端口\nrabbitmq-plugins enable rabbitmq_web_mqtt    默认端口websocket是15675 ws://118.24.2.2:15675/ws path是/ws\n</code></pre>\n<hr>\n<h2 id=\"管理后台页面\">管理后台页面</h2>\n<p><figure class=\"post__image\"><img decoding=\"async\" loading=\"lazy\" src=\"https://img-boo.oss-cn-chengdu.aliyuncs.com/markdown/img/202303291459546.png\" alt=\"img\"  data-is-external-image=\"true\"></figure></p>\n<h3 id=\"管控台的功能页面\">管控台的功能页面</h3>\n<ul>\n<li>概览(overview)：查看节点/集群状态</li>\n<li>连接(connections)：查看connection</li>\n<li>通道(channel)：查看channel</li>\n<li>交换机(Exchanges)：查看、操作交换机状态</li>\n<li>队列(Queue)：查看、操作队列状态</li>\n<li>管理(Admin)：高级管理功能 ##  5.常用命令</li>\n</ul>\n<h3 id=\"状态查看\">状态查看</h3>\n<p>查看状态：</p>\n<pre><code class=\"language-shell\">rabbitmqctl status\n</code></pre>\n<p>查看绑定：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_bindings \n</code></pre>\n<p>查看channel：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_channels \n</code></pre>\n<p>查看connection：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_connections \n</code></pre>\n<p>查看消费者：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_consumers \n</code></pre>\n<p>查看交换机：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_exchanges \n</code></pre>\n<p>查看队列：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_queues \n</code></pre>\n<p>删除队列：</p>\n<pre><code class=\"language-shell\">rabbitmqctl delete_queue \n</code></pre>\n<p>清空队列：</p>\n<pre><code class=\"language-shell\">rabbitmqctl purge_queue \n</code></pre>\n<h3 id=\"用户相关\">用户相关</h3>\n<p>新建用户：</p>\n<pre><code class=\"language-shell\">rabbitmqctl add_user \n</code></pre>\n<p>修改用户密码：</p>\n<pre><code class=\"language-shell\">rabbitmqctl change_password \n</code></pre>\n<p>删除用户：</p>\n<pre><code class=\"language-shell\">rabbitmqctl delete_user \n</code></pre>\n<p>查看用户：</p>\n<pre><code class=\"language-shell\">rabbitmqctl list_users \n</code></pre>\n<p>设置用户角色：</p>\n<pre><code class=\"language-shell\">rabbitmqctl rabbitmqctl set_user_tags\n</code></pre>\n<h3 id=\"应用启停\">应用启停</h3>\n<p>启动应用：</p>\n<pre><code class=\"language-shell\">rabbitmqctl start_app\n</code></pre>\n<p>关闭应用：</p>\n<pre><code class=\"language-shell\">rabbitmqctl stop_app\n</code></pre>\n<p>保留Erlang虚拟机（暂停） 关闭应用，并关闭Erlang虚拟机</p>\n<pre><code class=\"language-shell\">rabbitmqctl stop\n</code></pre>\n<h3 id=\"集群相关\">集群相关</h3>\n<p>加入集群：</p>\n<pre><code class=\"language-sh\">rabbitmqctl join_cluster\n</code></pre>\n<p>离开集群：</p>\n<pre><code class=\"language-shell\">rabbitmqctl reset\n</code></pre>\n<h3 id=\"镜像队列\">镜像队列</h3>\n<p>设置镜像队列：</p>\n<pre><code class=\"language-shell\">rabbitmqctl sync_queue\n</code></pre>\n<p>取消镜像队列：</p>\n<pre><code class=\"language-shell\">rabbitmqctl cancel_sync_queue\n</code></pre>\n<blockquote>\n<p> 附： <a href=\"http://tryrabbitmq.com/\">http://tryrabbitmq.com/</a> 消息发送模型模拟网站</p>\n</blockquote>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/26/Love.Death.and.Robots.S03E01.2022.AAC5.1.NF.HD1080P.Guan-Fang-Zhong-Zi.mp4_20220523_195308.822.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "java",
                   "develop",
                   "common"
            ],
            "date_published": "2023-03-29T20:11:29+08:00",
            "date_modified": "2023-07-11T10:55:48+08:00"
        },
        {
            "id": "https://ct-choochoo.github.io/ch-publii-pages/mockito-zhong-wen-wen-dang-zhuan-zai/",
            "url": "https://ct-choochoo.github.io/ch-publii-pages/mockito-zhong-wen-wen-dang-zhuan-zai/",
            "title": "Mockito 中文文档 ",
            "summary": "迁移到Mockito 2.0 验证某些行为 如何做一些测试桩 (Stub) 参数匹配器 (matchers) 验证函数的确切、最少、从未调用次数 为返回值为void的函数通过Stub抛出异常 按照顺序验证执行结果&hellip;",
            "content_html": "<ol>\n<li><a href=\"#0\">迁移到Mockito 2.0</a></li>\n<li><a href=\"#1\">验证某些行为</a></li>\n<li><a href=\"#2\">如何做一些测试桩 (Stub)</a></li>\n<li><a href=\"#3\">参数匹配器 (matchers)</a></li>\n<li><a href=\"#4\">验证函数的确切、最少、从未调用次数</a></li>\n<li><a href=\"#5\">为返回值为void的函数通过Stub抛出异常</a></li>\n<li><a href=\"#6\">按照顺序验证执行结果</a></li>\n<li><a href=\"#7\">确保交互(interaction)操作不会执行在mock对象上</a></li>\n<li><a href=\"#8\">查找冗余的调用</a></li>\n<li><a href=\"#9\">简化mock对象的创建</a></li>\n<li><a href=\"#10\">为连续的调用做测试桩 (stub)</a></li>\n<li><a href=\"#11\">为回调做测试桩</a></li>\n<li><a href=\"#12\">doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</a></li>\n<li><a href=\"#13\">监控真实对象</a></li>\n<li><a href=\"#14\">修改没有测试桩的调用的默认返回值 ( 1.7版本之后 )</a></li>\n<li><a href=\"#15\">为下一步的断言捕获参数 (1.8版本之后)</a></li>\n<li><a href=\"#16\">真实的局部mocks (1.8版本之后)</a></li>\n<li><a href=\"#17\">重置mocks对象 (1.8版本之后)</a></li>\n<li><a href=\"#18\">故障排查与验证框架的使用 (1.8版本之后)</a></li>\n<li><a href=\"#19\">行为驱动开发的别名 (1.8版本之后)</a></li>\n<li><a href=\"#20\">序列化mock对象</a></li>\n<li><a href=\"#21\">新的注解 : @Captor,@Spy,@ InjectMocks (1.8.3版本之后)</a></li>\n<li><a href=\"#22\">验证超时 (1.8.5版本之后)</a></li>\n<li><a href=\"#23\">自动初始化被@Spies, @InjectMocks注解的字段以及构造函数注入 (1.9.0版本之后)</a></li>\n<li><a href=\"#24\">单行测试桩 (1.9.0版本之后)</a></li>\n<li><a href=\"#25\">验证被忽略的测试桩 (1.9.0版本之后)</a></li>\n<li><a href=\"#26\">mock详情 (1.9.5版本之后)</a></li>\n<li><a href=\"#27\">delegate调用真实的实例 (1.9.5版本之后)</a></li>\n<li><a href=\"#28\">MockMaker API (1.9.5版本之后)</a></li>\n<li><a href=\"#29\">BDD风格的验证 (1.10.0版本之后)</a></li>\n<li><a href=\"#30\">追踪或者Mock抽象类 (1.10.12版本之后)</a></li>\n<li><a href=\"#31\">Mockito mock对象通过ClassLoader能被序列化/反序列化 (1.10.0版本之后)</a></li>\n<li><a href=\"#32\">deep stubs更好的支持泛型 (1.10.0版本之后)</a></li>\n<li><a href=\"#33\">Mockito JUnit 规则 (1.10.17版本之后)</a></li>\n<li><a href=\"#34\">开/关插件 (1.10.15版本之后)</a></li>\n<li><a href=\"#35\">自定义验证失败消息 (2.0.0版本之后)</a></li>\n</ol>\n<h2 id=\"0-迁移到-mockito-20\">0. 迁移到 Mockito 2.0</h2>\n<p>为了持续提升 Mockito 以及更进一步的提升单元测试体验，我们希望你升级到 Mockito 2.1.0。Mockito 遵循语意化的版本控制，除非有非常大的改变才会变化主版本号。在一个库的生命周期中，为了引入一系列有用的特性，修改已存在的行为或者 API 等重大变更是在所难免的。有关新版本（包括不兼容的更改）的全面指南，请参阅”Mockito 2” <a href=\"https://github.com/mockito/mockito/wiki/What's-new-in-Mockito-2\">wiki 页面</a>中的 “What’s new in Mockito 2”。我们希望你能够喜欢 Mockito 2.0!</p>\n<p>0.1. Mockito Android support\nWith Mockito version 2.6.1 we ship “native” Android support. To enable Android support, add the <code>mockito-android</code> library as dependency to your project. This artifact is published to the same Mockito organization and can be imported for Android as follows: You can continue to run the same unit tests on a regular VM by using the <code>mockito-core</code> artifact in your “testCompile” scope as shown above. Be aware that you cannot use the inline mock maker on Android due to limitations in the Android VM. If you encounter issues with mocking on Android, please open an issue on the official issue tracker. Do provide the version of Android you are working on and dependencies of your project.</p>\n<p>0.2. Configuration-free inline mock making\nStarting with version 2.7.6, we offer the ‘mockito-inline’ artifact that enables inline mock making without configuring the MockMaker extension file. To use this, add the <code>mockito-inline</code> instead of the <code>mockito-core</code> artifact as follows: Be aware that this artifact may be abolished when the inline mock making feature is integrated into the default mock maker.\n<b id=\"0\"></b></p>\n<h2 id=\"1-验证某些行为\">1. 验证某些行为</h2>\n<p>跟着我们的示例来 mock 一个 List，因为大家对 List 接口很熟悉（例如 add(),get(), clear()）。事实上，不要 mock List 接口本身,而要使用 List 的一个实例来替代。</p>\n<pre><code class=\"language-java\">// 静态导入会使代码更简洁\nimport static org.mockito.Mockito.*;\n\n// 创建 mock 对象\nList mockedList = mock(List.class);\n\n// 使用 mock 对象\nmockedList.add(&quot;one&quot;);\nmockedList.clear();\n\n// 验证\nverify(mockedList).add(&quot;one&quot;);\nverify(mockedList).clear();\n</code></pre>\n<p>一旦 mock 对象被创建了，mock 对象会记住所有的交互。然后你就可能选择性地验证你感兴趣的交互。\n<b id=\"1\"></b></p>\n<h2 id=\"2-如何做一些测试桩-stub\">2. 如何做一些测试桩 (Stub)</h2>\n<pre><code class=\"language-java\">// 你可以 mock 具体的类型，不仅只是接口\nLinkedList mockedList = mock(LinkedList.class);\n\n// 测试桩\nwhen(mockedList.get(0)).thenReturn(&quot;first&quot;);\nwhen(mockedList.get(1)).thenThrow(new RuntimeException());\n\n// 输出“first”\nSystem.out.println(mockedList.get(0));\n\n// 抛出异常\nSystem.out.println(mockedList.get(1));\n\n// 因为 get(999) 没有打桩，因此输出 null\nSystem.out.println(mockedList.get(999));\n\n// Although it is possible to verify a stubbed invocation, usually it&#39;s just redundant\n//If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n//If your code doesn&#39;t care what get(0) returns then it should not be stubbed. Not convinced? See here.\n// 验证 get(0) 被调用的次数\nverify(mockedList).get(0);\n</code></pre>\n<ul>\n<li>默认情况下，所有的函数都有返回值。mock 函数默认返回的是 null，一个空的集合或者一个被对象类型包装的内置类型，例如 0、false 对应的对象类型为 Integer、Boolean；</li>\n<li>测试桩函数可以被覆写：例如常见的测试桩函数可以用于初始化夹具，但是测试函数能够覆写它。请注意，覆写测试桩函数是一种可能存在潜在问题的做法；</li>\n<li>一旦测试桩函数被调用，该函数将会一直返回固定的值；</li>\n<li>上一次调用测试桩函数有时候极为重要——当你调用一个函数很多次时，最后一次调用可能是你所感兴趣的。\n<b id=\"2\"></b></li>\n</ul>\n<h2 id=\"3-参数匹配器-matchers\">3. 参数匹配器 (matchers)</h2>\n<p>Mockito 以自然的 java 风格来验证参数值: 使用 equals() 函数。有时当需要额外的灵活性时你可能需要使用参数匹配器 argument matchers :</p>\n<pre><code class=\"language-java\">// 使用内置的 anyInt() 参数匹配器\nwhen(mockedList.get(anyInt())).thenReturn(&quot;element&quot;);\n\n// 使用自定义的参数匹配器( 在isValid() 函数中返回你自己的匹配器实现 )\nwhen(mockedList.contains(argThat(isValid()))).thenReturn(&quot;element&quot;);\n\n// 输出 element\nSystem.out.println(mockedList.get(999));\n\n// 你也可以验证参数匹配器\nverify(mockedList).get(anyInt());\n</code></pre>\n<p>参数匹配器使验证和测试桩变得更灵活。<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Matchers.html\">点击这里</a>查看更多内置的匹配器以及自定义参数匹配器或者 hamcrest 匹配器的示例。</p>\n<p>如果仅仅是获取自定义参数匹配器的信息，查看<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentMatcher.html\">ArgumentMatcher类文档</a>即可。</p>\n<p>为了合理的使用复杂的参数匹配，使用 equals() 与 anyX() 的匹配器会使得测试代码更简洁、简单。\n有时，会迫使你重构代码以使用 equals() 匹配或者实现 equals() 函数来帮助你进行测试。\n同时建议你阅读<a href=\"#15\">第15章节</a>或者<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentCaptor.html\">ArgumentCaptor类文档</a>。ArgumentCaptor 是一个能够捕获参数值的特殊参数匹配器。</p>\n<p>参数匹配器的注意点 :</p>\n<p>如果你使用参数匹配器，所有参数都必须由匹配器提供。</p>\n<p>示例 : ( 该示例展示了如何多次应用于测试桩函数的验证 )</p>\n<pre><code class=\"language-java\">verify(mock).someMethod(anyInt(), anyString(), eq(&quot;third argument&quot;));\n// 上述代码是正确的，因为 eq() 也是一个参数匹配器\n\nverify(mock).someMethod(anyInt(), anyString(), &quot;third argument&quot;);\n// 上述代码是错误的，因为所有参数必须由匹配器提供，而参数 &quot;third argument&quot; 并非由参数匹配器提供，因此会抛出异常\n</code></pre>\n<p>像 anyObject(), eq() 这样的匹配器函数不会返回匹配器。它们会在内部将匹配器记录到一个栈当中，并且返回一个假的值，通常为null。\n<code>这样的实现是由于被Java编译器强加的静态类型安全</code>。结果就是你不能在验证或者测试桩函数之外使用 anyObject(), eq() 函数。</p>\n<p><b id=\"3\"></b></p>\n<h2 id=\"4-验证函数的确切、最少、从未调用次数\">4. 验证函数的确切、最少、从未调用次数</h2>\n<pre><code class=\"language-java\">mockedList.add(&quot;once&quot;);\n\nmockedList.add(&quot;twice&quot;);\nmockedList.add(&quot;twice&quot;);\n\nmockedList.add(&quot;three times&quot;);\nmockedList.add(&quot;three times&quot;);\nmockedList.add(&quot;three times&quot;);\n\n// 下面的两个验证函数效果一样，因为 verify 默认验证的就是 times(1)\nverify(mockedList).add(&quot;once&quot;);\nverify(mockedList, times(1)).add(&quot;once&quot;);\n\n// 验证具体的执行次数\nverify(mockedList, times(2)).add(&quot;twice&quot;);\nverify(mockedList, times(3)).add(&quot;three times&quot;);\n\n// 使用never()进行验证,never相当于times(0)\nverify(mockedList, never()).add(&quot;never happened&quot;);\n\n// 使用atLeast()/atMost()\nverify(mockedList, atMostOnce()).add(&quot;once&quot;);\nverify(mockedList, atLeastOnce()).add(&quot;three times&quot;);\nverify(mockedList, atLeast(2)).add(&quot;five times&quot;);\nverify(mockedList, atMost(5)).add(&quot;three times&quot;);\n</code></pre>\n<p>verify 函数默认验证的是执行了 times(1)，也就是某个测试函数是否执行了 1 次。因此，times(1) 通常被省略了。</p>\n<p><b id=\"4\"></b></p>\n<h2 id=\"5-为返回值为void的函数通过stub抛出异常\">5. 为返回值为void的函数通过Stub抛出异常</h2>\n<pre><code class=\"language-java\">doThrow(new RuntimeException()).when(mockedList).clear();\n\n// 调用这句代码会抛出异常\nmockedList.clear();\n</code></pre>\n<p>关于 doThrow | doAnswer 等函数的信息请阅读<a href=\"#12\">第 12 节</a>。</p>\n<p><b id=\"5\"></b></p>\n<h2 id=\"6-验证执行执行顺序\">6. 验证执行执行顺序</h2>\n<pre><code class=\"language-java\">// A. 验证 mock 一个对象的函数执行顺序\nList singleMock = mock(List.class);\n\n// 使用 singleMock\nsingleMock.add(&quot;was added first&quot;);\nsingleMock.add(&quot;was added second&quot;);\n\n// 为该 mock 对象创建一个 inOrder 对象\nInOrder inOrder = inOrder(singleMock);\n\n// 确保 add 函数首先执行的是 add(&quot;was added first&quot;)，然后才是 add(&quot;was added second&quot;)\ninOrder.verify(singleMock).add(&quot;was added first&quot;);\ninOrder.verify(singleMock).add(&quot;was added second&quot;);\n\n// B. 验证多个 mock 对象的函数执行顺序\nList firstMock = mock(List.class);\nList secondMock = mock(List.class);\n\n// 使用 mock\nfirstMock.add(&quot;was called first&quot;);\nsecondMock.add(&quot;was called second&quot;);\n\n// 为这两个 mock 对象创建 inOrder 对象\nInOrder inOrder = inOrder(firstMock, secondMock);\n\n// 验证它们的执行顺序\ninOrder.verify(firstMock).add(&quot;was called first&quot;);\ninOrder.verify(secondMock).add(&quot;was called second&quot;);\n\n// A 和 B 可以按照你的意愿组合在一起\n</code></pre>\n<p>验证执行顺序是非常灵活的：你不需要一个一个的验证所有交互，只需要验证你感兴趣的对象即可。\n另外，你可以仅通过那些需要验证顺序的 mock 对象来创建 InOrder 对象。</p>\n<p><b id=\"6\"></b></p>\n<h2 id=\"7-确保交互interaction操作不会执行在-mock-对象上\">7. 确保交互(interaction)操作不会执行在 mock 对象上</h2>\n<pre><code class=\"language-java\">// 使用 Mock 对象\nmockOne.add(&quot;one&quot;);\n\n// 普通验证\nverify(mockOne).add(&quot;one&quot;);\n\n// 验证某个交互是否从未被执行\nverify(mockOne, never()).add(&quot;two&quot;);\n\n// 验证 mock 对象没有交互过\nverifyZeroInteractions(mockTwo, mockThree);\n</code></pre>\n<p><b id=\"7\"></b></p>\n<h2 id=\"8-查找冗余的调用\">8. 查找冗余的调用</h2>\n<pre><code class=\"language-java\">// 使用 mock\nmockedList.add(&quot;one&quot;);\nmockedList.add(&quot;two&quot;);\n\nverify(mockedList).add(&quot;one&quot;);\n\n// 下面的验证将会失败\nverifyNoMoreInteractions(mockedList);\n</code></pre>\n<p>一些用户可能会在频繁地使用 <code>verifyNoMoreInteractions()</code>，甚至在每个测试函数中都用。但是 <code>verifyNoMoreInteractions()</code> 并不建议在每个测试函数中都使用。<code>verifyNoMoreInteractions()</code> 在交互测试套件中只是一个便利的验证，它的作用是当你需要验证是否存在冗余调用时。滥用它将导致测试代码的可维护性降低。</p>\n<p><code>never()</code> 是一种更为明显且易于理解的形式。</p>\n<p><b id=\"8\"></b></p>\n<h2 id=\"9-简化-mock-对象的创建---mock-注解\">9. 简化 mock 对象的创建 - @Mock 注解</h2>\n<ul>\n<li>最小化重复的创建代码</li>\n<li>使测试类的代码可读性更高</li>\n<li>使验证错误更易于阅读，因为字段名可用于标识 mock 对象</li>\n</ul>\n<pre><code class=\"language-java\">public class ArticleManagerTest {\n\n   @Mock private ArticleCalculator calculator;\n   @Mock private ArticleDatabase database;\n   @Mock private UserProvider userProvider;\n\n   private ArticleManager manager;\n</code></pre>\n<p>注意！下面这句代码需要在运行测试函数之前被调用，一般放到测试类的基类或者 test runner 中:</p>\n<pre><code class=\"language-java\">MockitoAnnotations.initMocks(testClass);\n</code></pre>\n<p>你可以使用内置的 runner: [MockitoJUnitRunner] [runner] 或者一个 rule : <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoJUnit.html#rule()\">MockitoRule</a>。\n对于 JUnit5 测试，在 45 节有描述。\n关于 mock 注解的更多信息可以阅读 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html\">MockitoAnnotations文档</a>。</p>\n<p><b id=\"9\"></b></p>\n<h2 id=\"10-为连续的调用做测试桩-stub\">10. 为连续的调用做测试桩 (stub)</h2>\n<p>有时我们需要为同一个函数调用的不同的返回值或异常做测试桩。典型的运用就是使用 mock 迭代器。\n原始版本的 Mockito 并没有这个特性，例如，可以使用 Iterable 或者简单的集合来替换迭代器。这些方法提供了更原始的方式。\n在一些场景中为连续的调用做测试桩会很有用。示例如下 ：</p>\n<pre><code class=\"language-java\">when(mock.someMethod(&quot;some arg&quot;))\n  .thenThrow(new RuntimeException())\n  .thenReturn(&quot;foo&quot;);\n\n// 第一次调用 : 抛出运行时异常\nmock.someMethod(&quot;some arg&quot;);\n\n// 第二次调用 : 输出 &quot;foo&quot;\nSystem.out.println(mock.someMethod(&quot;some arg&quot;));\n\n// 后续调用 : 也是输出 &quot;foo&quot;\nSystem.out.println(mock.someMethod(&quot;some arg&quot;));\n</code></pre>\n<p>另外，连续调用的另一种更简短的版本 :</p>\n<pre><code class=\"language-java\">// 第一次调用时返回 &quot;one&quot;，第二次返回 &quot;two&quot;，第三次返回 &quot;three&quot;\n when(mock.someMethod(&quot;some arg&quot;))\n   .thenReturn(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);\n</code></pre>\n<p><b id=\"10\"></b></p>\n<h2 id=\"11-为回调做测试桩\">11. 为回调做测试桩</h2>\n<p>Allows stubbing with generic Answer interface.\n运行为泛型接口 Answer 打桩。</p>\n<p>在最初的Mockito里也没有这个具有争议性的特性。我们建议使用thenReturn() 或thenThrow()来打桩。这两种方法足够用于测试或者测试驱动开发。</p>\n<pre><code class=\"language-java\">when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n    Object answer(InvocationOnMock invocation) {\n        Object[] args = invocation.getArguments();\n        Object mock = invocation.getMock();\n        return &quot;called with arguments: &quot; + args;\n    }\n});\n\n//Following prints &quot;called with arguments: foo&quot;\n// 输出 : &quot;called with arguments: foo&quot;\nSystem.out.println(mock.someMethod(&quot;foo&quot;));\n</code></pre>\n<p><b id=\"11\"></b></p>\n<h2 id=\"12-doreturn、dothrow、doanswer、donothing、docallrealmethod系列方法的运用\">12. doReturn()、doThrow()、doAnswer()、doNothing()、doCallRealMethod()系列方法的运用</h2>\n<p>通过<code>when(Object)</code>为无返回值的函数打桩有不同的方法,因为编译器不喜欢void函数在括号内…</p>\n<p>使用<code>doThrow(Throwable)</code> 替换<code>stubVoid(Object)</code>来为void函数打桩是为了与<code>doAnswer()</code>等函数族保持一致性。</p>\n<p>当你想为void函数打桩时使用含有一个exception 参数的<code>doAnswer()</code> :</p>\n<pre><code class=\"language-java\">doThrow(new RuntimeException()).when(mockedList).clear();\n\n//following throws RuntimeException:\n// 下面的代码会抛出异常\nmockedList.clear();\n</code></pre>\n<p>当你调用<code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code> and <code>doCallRealMethod()</code> 这些函数时可以在适当的位置调用<code>when()</code>函数. 当你需要下面这些功能时这是必须的:</p>\n<ul>\n<li>测试void函数</li>\n<li>在受监控的对象上测试函数</li>\n<li>不知一次的测试为同一个函数，在测试过程中改变mock对象的行为。</li>\n</ul>\n<p>但是在调用<code>when()</code>函数时你可以选择是否调用这些上述这些函数。</p>\n<p>阅读更多关于这些方法的信息:</p>\n<ul>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doReturn(java.lang.Object)\">doReturn(Object)</a></li>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doThrow(java.lang.Throwable)\">doThrow(Throwable)</a></li>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doThrow(java.lang.Class)\">doThrow(Class)</a></li>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)\">doAnswer(Answer)</a></li>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doNothing()\">doNothing()</a></li>\n<li><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#doCallRealMethod()\">doCallRealMethod()</a></li>\n</ul>\n<p><b id=\"12\"></b></p>\n<h2 id=\"13-监控真实对象\">13. 监控真实对象</h2>\n<p>你可以为真实对象创建一个监控(spy)对象。当你使用这个spy对象时真实的对象也会也调用，除非它的函数被stub了。尽量少使用spy对象，使用时也需要小心形式，例如spy对象可以用来处理遗留代码。</p>\n<p>监控一个真实的对象可以与“局部mock对象”概念结合起来。在1.8之前，mockito的监控功能并不是真正的局部mock对象。原因是我们认为局部mock对象的实现方式并不好，在某些时候我发现一些使用局部mock对象的合法用例。（第三方接口、临时重构遗留代码，完整的文章在<a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/\">这里</a> ）</p>\n<pre><code class=\"language-java\">List list = new LinkedList();\nList spy = spy(list);\n\n//optionally, you can stub out some methods:\n// 你可以为某些函数打桩\nwhen(spy.size()).thenReturn(100);\n\n//using the spy calls *real* methods\n// 通过spy对象调用真实对象的函数\nspy.add(&quot;one&quot;);\nspy.add(&quot;two&quot;);\n\n//prints &quot;one&quot; - the first element of a list\n// 输出第一个元素\nSystem.out.println(spy.get(0));\n\n//size() method was stubbed - 100 is printed\n// 因为size()函数被打桩了,因此这里返回的是100\nSystem.out.println(spy.size());\n\n//optionally, you can verify\n// 交互验证\nverify(spy).add(&quot;one&quot;);\nverify(spy).add(&quot;two&quot;);\n</code></pre>\n<p>理解监控真实对象非常重要！</p>\n<p>有时，在监控对象上使用<code>when(Object)</code>来进行打桩是不可能或者不切实际的。因此，当使用监控对象时请考虑<code>doReturn|Answer|Throw()</code>函数族来进行打桩。例如 :</p>\n<pre><code class=\"language-java\">List list = new LinkedList();\nList spy = spy(list);\n\n//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n// 不可能 : 因为当调用spy.get(0)时会调用真实对象的get(0)函数,此时会发生IndexOutOfBoundsException异常，因为真实List对象是空的\n   when(spy.get(0)).thenReturn(&quot;foo&quot;);\n\n//You have to use doReturn() for stubbing\n// 你需要使用doReturn()来打桩\ndoReturn(&quot;foo&quot;).when(spy).get(0);\n</code></pre>\n<p>Mockito并不会为真实对象代理函数调用，实际上它会拷贝真实对象。因此如果你保留了真实对象并且与之交互，不要期望从监控对象得到正确的结果。当你在监控对象上调用一个没有被stub的函数时并不会调用真实对象的对应函数，你不会在真实对象上看到任何效果。</p>\n<p>因此结论就是 : 当你在监控一个真实对象时，你想在stub这个真实对象的函数，那么就是在自找麻烦。或者你根本不应该验证这些函数。</p>\n<p><b id=\"13\"></b></p>\n<h2 id=\"14-修改没有测试桩的调用的默认返回值--17版本之后-\">14. 修改没有测试桩的调用的默认返回值 ( 1.7版本之后 )</h2>\n<p>你可以指定策略来创建mock对象的返回值。这是一个高级特性，通常来说，你不需要写这样的测试。然后，它对于遗留系统来说是很有用处的。当你不需要为函数调用打桩时你可以指定一个默认的answer。</p>\n<pre><code class=\"language-java\">Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\nFoo mockTwo = mock(Foo.class, new YourOwnAnswer());\n</code></pre>\n<p>关于RETURNS_SMART_NULLS更多的信息请查看 :\n<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#RETURNS_SMART_NULLS\">RETURNS_SMART_NULLS文档</a> 。</p>\n<p><b id=\"14\"></b></p>\n<h2 id=\"15-为下一步的断言捕获参数-18版本之后\">15. 为下一步的断言捕获参数 (1.8版本之后)</h2>\n<p>Mockito以java代码风格的形式来验证参数值 : 即通过使用<code>equals()</code>函数。这也是我们推荐用于参数匹配的方式，因为这样会使得测试代码更简单、简洁。在某些情况下，当验证交互之后要检测真实的参数值时这将变得有用。例如 ：</p>\n<pre><code class=\"language-java\">ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n// 参数捕获\nverify(mock).doSomething(argument.capture());\n// 使用equal断言\nassertEquals(&quot;John&quot;, argument.getValue().getName());\n</code></pre>\n<p>警告 : 我们建议使用没有测试桩的ArgumentCaptor来验证，因为使用含有测试桩的ArgumentCaptor会降低测试代码的可读性，因为captor是在断言代码块之外创建的。另一个好处是它可以降低本地化的缺点，因为如果测试桩函数没有被调用，那么参数就不会被捕获。总之，ArgumentCaptor与自定义的参数匹配器相关(可以查看<a href=\"http://blog.fcj.one/ArgumentMatcher\">ArgumentMatcher类的文档</a> )。这两种技术都能用于检测外部传递到Mock对象的参数。然而，使用ArgumentCaptor在以下的情况下更合适 :</p>\n<ul>\n<li>自定义不能被重用的参数匹配器</li>\n<li>你仅需要断言参数值</li>\n</ul>\n<p>自定义参数匹配器相关的资料你可以参考<a href=\"http://blog.fcj.one/ArgumentMatcher\">ArgumentMatcher</a>文档。\n<b id=\"15\"></b></p>\n<h2 id=\"16-真实的局部mocks-18版本之后\">16. 真实的局部mocks (1.8版本之后)</h2>\n<p>在内部通过邮件进行了无数争辩和讨论后，最终 Mockito 决定支持部分测试，早前我们不支持是因为我们认为部分测试会让代码变得糟糕。然而，我们发现了部分测试真正合理的用法。<a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring/\">详情点这</a></p>\n<p>在 Mockito 1.8 之前，spy() 方法并不会产生真正的部分测试，而这无疑会让一些开发者困惑。更详细的内容可以看：<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#13\">这里</a> 或 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)\">Java 文档</a></p>\n<pre><code class=\"language-java\">//you can create partial mock with spy() method:\nList list = spy(new LinkedList());\n\n//you can enable partial mock capabilities selectively on mocks:\nFoo mock = mock(Foo.class);\n//Be sure the real implementation is &#39;safe&#39;.\n//If real implementation throws exceptions or depends on specific state of the object then you&#39;re in trouble.\nwhen(mock.someMethod()).thenCallRealMethod();\n</code></pre>\n<p>一如既往，你会去读部分测试的警告部分：面向对象编程通过将抽象的复杂度拆分为一个个独立，精确的 SRPy 对象中，降低了抽象处理的复杂度。那部分测试是怎么遵循这个规范的呢？事实上部分测试并没有遵循这个规范……部分测试通常意味着抽象的复杂度被移动到同一个对象的不同方法中，在大多数情况下，这不会是你想要的应用架构方式。</p>\n<p>然而，在一些罕见的情况下部分测试才会是易用的：处理不能轻易修改的代码（第三方接口，临时重构的遗留代码等等）。然而，为了新的，测试驱动和架构优秀的代码，我是不会使用部分测试的。\n<b id=\"16\"></b></p>\n<h2 id=\"17-重置mocks对象-18版本之后\">17. 重置mocks对象 (1.8版本之后)</h2>\n<p>聪明的 Mockito 使用者很少会用到这个特性，因为他们知道这是出现糟糕测试单元的信号。通常情况下你不会需要重设你的测试单元，只需要为每一个测试方法重新创建一个测试单元就可以了。</p>\n<p>如果你真的想通过 reset() 方法满足某些需求的话，请考虑实现简单，小而且专注于测试方法而不是冗长，精确的测试。首先可能出现的代码异味就是测试方法中间那的 reset() 方法。这可能意味着你已经过度测试了。请遵循测试方法的呢喃：请让我们小，而且专注于单一的行为上。在 Mockito 邮件列表中就有好几个讨论是和这个有关的。</p>\n<p>添加 reset() 方法的唯一原因就是让它能与容器注入的测试单元协作。详情看 <a href=\"http://code.google.com/p/mockito/issues/detail?id=55\">issue 55</a> 或 <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">FAQ</a>。</p>\n<p>别自己给自己找麻烦，reset() 方法在测试方法的中间确实是代码异味。</p>\n<pre><code class=\"language-java\">List mock = mock(List.class);\nwhen(mock.size()).thenReturn(10);\nmock.add(1);\n\nreset(mock);\n//at this point the mock forgot any interactions &amp; stubbing\n</code></pre>\n<p><b id=\"17\"></b></p>\n<h2 id=\"18-故障排查与验证框架的使用-18版本之后\">18. 故障排查与验证框架的使用 (1.8版本之后)</h2>\n<p>首先，如果出现了任何问题，我建议你先看 <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">Mockito FAQ</a>。</p>\n<p>任何你提的问题都会被提交到 Mockito 的<a href=\"http://groups.google.com/group/mockito\">邮件列表</a>中。</p>\n<p>然后你应该知道 Mockito 会验证你是否始终以正确的方式使用它，对此有疑惑的话不妨看看 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#validateMockitoUsage()\">validateMockitoUsage()</a> 的文档说明。\n<b id=\"18\"></b></p>\n<h2 id=\"19-行为驱动开发的别名-18版本之后\">19. 行为驱动开发的别名 (1.8版本之后)</h2>\n<p>行为驱动开发实现测试单元的模式将 //given //when //then comments 视作测试方法的基础，这也是我们实现单元测试时被建议做的！</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">你可以在这开始学习有关 BDD 的知识</a></p>\n<p>问题是当信息没有很好地与 //given //when //then comments 交互时，扮演规范角色的测试桩 API 就会出现问题。这是因为测试桩属于给定测试单元的组件，而且不是任何测试的组件。因此 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html\">BDDMockito</a> 类介绍了一个别名，使你的测试桩方法调用 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html#given(T)\">BDDMockito.given(Object)</a> 方法。现在它可以很好地和给定的 BDD 模式的测试单元组件进行交互。</p>\n<pre><code class=\"language-java\">import static org.mockito.BDDMockito.*;\n\nSeller seller = mock(Seller.class);\nShop shop = new Shop(seller);\n\npublic void shouldBuyBread() throws Exception {\n  //given\n  given(seller.askForBread()).willReturn(new Bread());\n\n  //when\n  Goods goods = shop.buyBread();\n\n  //then\n  assertThat(goods, containBread());\n}\n</code></pre>\n<p><b id=\"19\"></b></p>\n<h2 id=\"20-序列化mock对象\">20. 序列化mock对象</h2>\n<p>模拟对象可以被序列化。有了这个特性你就可以在依赖被序列化的情况下使用模拟对象了。</p>\n<p>警告：这个特性很少在单元测试中被使用。</p>\n<p>To create serializable mock use <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#serializable()\">MockSettings.serializable()</a>:</p>\n<p>这个特性通过 BDD 拥有不可考外部依赖的特性的具体用例实现，来自外部依赖的 Web 环境和对象会被序列化，然后在不同层之间被传递。</p>\n<pre><code class=\"language-java\">List serializableMock = mock(List.class, withSettings().serializable());\n</code></pre>\n<p>The mock can be serialized assuming all the normal <a href=\"http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html\">serialization requirements</a> are met by the class.</p>\n<p>模拟对象能被序列化假设所有普通的序列化要求都被类满足了。</p>\n<p>让一个真实的侦查对象可序列化需要多一些努力，因为 spy(…) 方法没有接收 MockSettings 的重载版本。不过不用担心，你几乎不可能用到这。</p>\n<pre><code class=\"language-java\">List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();\nList&lt;Object&gt; spy = mock(ArrayList.class, withSettings()\n                .spiedInstance(list)\n                .defaultAnswer(CALLS_REAL_METHODS)\n                .serializable());\n</code></pre>\n<p><b id=\"20\"></b></p>\n<h2 id=\"21-新的注解--captorspy-injectmocks-183版本之后\">21. 新的注解 : @Captor,@Spy,@ InjectMocks (1.8.3版本之后)</h2>\n<p>V1.8.3 带来的新注解在某些场景下可能会很实用</p>\n<p>@<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Captor.html\">Captor</a> 简化 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/ArgumentCaptor.html\">ArgumentCaptor</a> 的创建 - 当需要捕获的参数是一个令人讨厌的通用类，而且你想避免编译时警告。</p>\n<p>@<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html\">Spy</a> - 你可以用它代替 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)\">spy(Object) 方法</a></p>\n<p>@<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html\">InjectMocks</a> - 自动将模拟对象或侦查域注入到被测试对象中。需要注意的是 @InjectMocks 也能与 @Spy 一起使用，这就意味着 Mockito 会注入模拟对象到测试的部分测试中。它的复杂度也是你应该使用部分测试原因。</p>\n<p>所有新的注解仅仅在 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)\">MockitoAnnotations.initMocks(Object)</a> 方法中被处理，就像你在 built-in runner 中使用的 @<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mock.html\">Mock</a> 注解：<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html\">MockitoJUnitRunner</a> 或 规范: <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html\">MockitoRule</a>.\n<b id=\"21\"></b></p>\n<h2 id=\"22-验证超时-185版本之后\">22. 验证超时 (1.8.5版本之后)</h2>\n<p>允许带有暂停的验证。这使得一个验证去等待一段特定的时间，以获得想要的交互而不是如果还没有发生事件就带来的立即失败。在并发条件下的测试这会很有用。</p>\n<p>感觉起来这个特性应该很少被使用 - 指出更好的测试多线程系统的方法。</p>\n<p>还没有实现去和 InOrder 验证协作。</p>\n<p>例子：</p>\n<pre><code class=\"language-java\">//passes when someMethod() is called within given time span\nverify(mock, timeout(100)).someMethod();\n//above is an alias to:\nverify(mock, timeout(100).times(1)).someMethod();\n\n//passes when someMethod() is called *exactly* 2 times within given time span\nverify(mock, timeout(100).times(2)).someMethod();\n\n//passes when someMethod() is called *at least* 2 times within given time span\nverify(mock, timeout(100).atLeast(2)).someMethod();\n\n//verifies someMethod() within given time span using given verification mode\n//useful only if you have your own custom verification modes.\nverify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n</code></pre>\n<p><b id=\"22\"></b></p>\n<h2 id=\"23-自动初始化被spies-injectmocks注解的字段以及构造函数注入-190版本之后\">23. 自动初始化被@Spies, @InjectMocks注解的字段以及构造函数注入 (1.9.0版本之后)</h2>\n<p>Mockito 现在会通过注入构造方法、setter 或域注入尽可能初始化带有 @<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html\">Spy</a> 和 @<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html\">InjectMocks</a> 注解的域或方法。</p>\n<p>为了利用这一点特性，你需要使用 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)\">MockitoAnnotations.initMocks(Object)</a>, <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html\">MockitoJUnitRunner</a> 或 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoRule.html\">MockitoRule</a>。</p>\n<p>为了 InjectMocks 请在 Java 文档中了解更多可用的技巧和注入的规范</p>\n<pre><code class=\"language-java\">//instead:\n@Spy BeerDrinker drinker = new BeerDrinker();\n//you can write:\n@Spy BeerDrinker drinker;\n\n//same applies to @InjectMocks annotation:\n@InjectMocks LocalPub;\n</code></pre>\n<p><b id=\"23\"></b></p>\n<h2 id=\"24-单行测试桩-190版本之后\">24. 单行测试桩 (1.9.0版本之后)</h2>\n<p>Mockito 现在允许你在使用测试桩时创建模拟对象。基本上，它允许在一行代码中创建一个测试桩，这对保持代码的整洁很有用。举例来说，有些乏味的测试桩会被创建，并在测试初始化域时被打入，例如：</p>\n<pre><code class=\"language-java\">public class CarTest {\n  Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();\n\n  @Test public void should... {}\n</code></pre>\n<p><b id=\"24\"></b></p>\n<h2 id=\"25-验证被忽略的测试桩-190版本之后\">25. 验证被忽略的测试桩 (1.9.0版本之后)</h2>\n<p>Mockito 现在允许为了验证无视测试桩。在与 verifyNoMoreInteractions() 方法或验证 inOrder() 方法耦合时，有些时候会很有用。帮助避免繁琐的打入测试桩调用验证 - 显然我们不会对验证测试桩感兴趣。</p>\n<p>警告，ignoreStubs() 可能会导致 verifyNoMoreInteractions(ignoreStubs(…)) 的过度使用。谨记在心，Mockito 没有推荐用 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)\">verifyNoMoreInteractions()</a> 方法连续地施用于每一个测试中，原因在 Java 文档中有。</p>\n<p>一些例子：</p>\n<pre><code class=\"language-java\">verify(mock).foo();\nverify(mockTwo).bar();\n\n//ignores all stubbed methods:\nverifyNoMoreInvocations(ignoreStubs(mock, mockTwo));\n\n//creates InOrder that will ignore stubbed\nInOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));\ninOrder.verify(mock).foo();\ninOrder.verify(mockTwo).bar();\ninOrder.verifyNoMoreInteractions();\n</code></pre>\n<p>更好的例子和更多的细节都可以在 Java 文档的 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#ignoreStubs(java.lang.Object...)\">ignoreStubs(Object…)</a> 部分看到。\n<b id=\"25\"></b></p>\n<h2 id=\"26-mock详情-195版本之后\">26. mock详情 (1.9.5版本之后)</h2>\n<p>为了区别一个对象是模拟对象还是侦查对象：</p>\n<pre><code class=\"language-java\">Mockito.mockingDetails(someObject).isMock();\nMockito.mockingDetails(someObject).isSpy();\n</code></pre>\n<p><a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockingDetails.html#isMock()\">MockingDetails.isMock()</a> 和 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockingDetails.html#isSpy()\">MockingDetails.isSpy()</a> 方法都会返回一个布尔值。因为一个侦查对象只是模拟对象的一种变种，所以 isMock() 方法在对象是侦查对象是会返回 true。在之后的 Mockito 版本中 MockingDetails 会变得更健壮，并提供其他与模拟对象相关的有用信息，例如：调用，测试桩信息，等等……\n<b id=\"26\"></b></p>\n<h2 id=\"27-委托调用真实实例-since-195\">27. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#delegating_call_to_real_instance\">委托调用真实实例</a> (Since 1.9.5)</h2>\n<p>当<strong>使用常规的 spy API 去 mock 或者 spy 一个对象很困难</strong>时可以用 delegate 来 spy 或者 mock 对象的某一部分。\n从 Mockito 的 1.10.11 版本开始， delegate 有可能和 mock 的类型相同也可能不同。如果不是同一类型，\ndelegate 类型需要提供一个匹配方法否则就会抛出一个异常。下面是关于这个特性的一些用例:</p>\n<ul>\n<li>带有 interface 的 final 类</li>\n<li>已经自定义代理的对象</li>\n<li>带有 finalize 方法的特殊对象，就是避免重复执行。</li>\n</ul>\n<p>和常规 spy 的不同:</p>\n<ul>\n<li>标准的 spy <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)\">(spy(Object))</a> 包含被 spy 实例的所有状态信息，方法在 spy 对象上被调用。被 spy 的对象只在 mock\n创建时被用来拷贝状态信息。如果你通过标准 spy 调用一个方法，这个 spy 会调用其内部的其他方法记录这次操作，\n以便后面验证使用。等效于存根 (stubbed)操作。</li>\n<li>mock delegates 只是简单的把所有方法委托给 delegate。delegate 一直被当成它代理的方法使用。如果你\n从一个 mock 调用它被委托的方法，它会调用其内部方法，这些调用不会被记录，stubbing 在这里也不会生效。\nMock 的 delegates 相对于标准的 spy 来说功能弱了很多，不过在标准 spy 不能被创建的时候很有用。</li>\n</ul>\n<p>更多信息可以看这里 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/AdditionalAnswers.html#delegatesTo(java.lang.Object)\">AdditionalAnswers.delegatesTo(Object)</a>.</p>\n<hr>\n<p><b id=\"27\"></b></p>\n<h2 id=\"28-mockmaker-api-since-195\">28. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#mock_maker_plugin\">MockMaker API</a> (Since 1.9.5)</h2>\n<p>为了满足用户的需求和 Android 平台使用。Mockito 现在提供一个扩展点，允许替换代理生成引擎。默认情况下，Mockito 使用 cglib 创建动态代理。</p>\n<p>这个扩展点是为想要扩展 Mockito 功能的高级用户准备的。比如，我们现在就可以在 dexmaker 的帮助下使用 Mockito\n测试 Android。</p>\n<p>更多的细节，原因和示例请看 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/plugins/MockMaker.html\">MockMaker</a> 的文档。</p>\n<hr>\n<p><b id=\"28\"></b></p>\n<h2 id=\"29-new-bdd-风格的验证-since-1100\">29. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#BDD_behavior_verification\">(new) BDD 风格的验证</a> (Since 1.10.0)</h2>\n<p>开启 Behavior Driven Development (BDD) 风格的验证可以通过 BBD 的关键词 <strong>then</strong> 开始验证。</p>\n<pre><code class=\"language-java\">given(dog.bark()).willReturn(2);\n\n// when\n...\n\nthen(person).should(times(2)).ride(bike);\n</code></pre>\n<p>更多信息请查阅 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/BDDMockito.html#then(T)\">BDDMockito.then(Object)</a> .</p>\n<hr>\n<p><b id=\"29\"></b></p>\n<h2 id=\"30-new-spying-或-mocking-抽象类-since-11012\">30. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spying_abstract_classes\">(new) Spying 或 mocking 抽象类</a> (Since 1.10.12)</h2>\n<p>现在可以方便的 spy 一个抽象类。注意，过度使用 spy 或许意味着代码的设计上有问题。(see <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#spy(T)\">spy(Object)</a>).</p>\n<p>之前，spying 只可以用在实例对象上。而现在新的 API 可以在创建一个 mock 实例时使用构造函数。这对 mock\n一个抽象类来说是很重要的，这样使用者就不必再提供一个抽象类的实例了。目前的话只支持无参构造函数，\n如果你认为这样还不够的话欢迎向我们反馈。</p>\n<pre><code class=\"language-java\">//convenience API, new overloaded spy() method:\n SomeAbstract spy = spy(SomeAbstract.class);\n\n //Robust API, via settings builder:\n OtherAbstract spy = mock(OtherAbstract.class, withSettings()\n    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));\n\n //Mocking a non-static inner abstract class:\n InnerAbstract spy = mock(InnerAbstract.class, withSettings()\n    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));\n</code></pre>\n<p>更多信息请见 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#useConstructor()\">MockSettings.useConstructor()</a> .</p>\n<hr>\n<p><b id=\"30\"></b></p>\n<h2 id=\"31-new-mockito-mocks-可以通过-classloaders-序列化反序列化-since-1100\">31. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#serilization_across_classloader\">(new) Mockito mocks 可以通过 classloaders 序列化/反序列化</a> (Since 1.10.0)</h2>\n<p>Mockito 通过 classloader 引入序列化。和其他形式的序列化一样，所有 mock 层的对象都要被序列化，\n包括 answers。因为序列化模式需要大量的工作，所以这是一个可选择设置。</p>\n<pre><code class=\"language-java\">// 常规的 serialization\nmock(Book.class, withSettings().serializable());\n\n// 通过 classloaders 序列化\nmock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));\n</code></pre>\n<p>更多信息请查看 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockSettings.html#serializable(org.mockito.mock.SerializableMode)\">MockSettings.serializable(SerializableMode)</a>.</p>\n<hr>\n<p><b id=\"31\"></b></p>\n<h2 id=\"32-new-deep-stubs-更好的泛型支持-since-1100\">32. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#better_generic_support_with_deep_stubs\">(new) Deep stubs 更好的泛型支持</a> (Since 1.10.0)</h2>\n<p>Deep stubbing 现在可以更好的查找类的泛型信息。这就意味着像这样的类\n不必去 mock 它的行为就可以使用。</p>\n<pre><code class=\"language-java\">class Lines extends List&lt;Line&gt; {\n     // ...\n }\n\n lines = mock(Lines.class, RETURNS_DEEP_STUBS);\n\n // Now Mockito understand this is not an Object but a Line\n Line line = lines.iterator().next();\n</code></pre>\n<p>请注意，大多数情况下 mock 返回一个 mock 对象是错误的。</p>\n<hr>\n<p><b id=\"32\"></b></p>\n<h2 id=\"33-new-mockito-junit-rule-since-11017\">33. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mockito.html#mockito_junit_rule\">(new) Mockito JUnit rule</a> (Since 1.10.17)</h2>\n<p>Mockito 现在提供一个 JUnit rule。目前为止，有两种方法可以初始化 fields ，使用 Mockito 提供的注解比如\n<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Mock.html\">@Mock</a>, <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/Spy.html\">@Spy</a>, <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/InjectMocks.html\">@InjectMocks</a> 等等。</p>\n<ul>\n<li>用 @RunWith(<a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/runners/MockitoJUnitRunner.html\">@MockitoJUnitRunner.class</a>) 标注 JUnit 测试类</li>\n<li>在 @Before 之前调用 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)\">MockitoAnnotations.initMocks(Object)</a></li>\n</ul>\n<p>现在你可以选择使用一个 rule:</p>\n<pre><code class=\"language-java\">@RunWith(YetAnotherRunner.class)\npublic class TheTest {\n    @Rule public MockitoRule mockito = MockitoJUnit.rule();\n    // ...\n}\n</code></pre>\n<p>更多信息到这里查看 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/junit/MockitoJUnit.html#rule()\">MockitoJUnit.rule()</a>.</p>\n<hr>\n<p><b id=\"33\"></b></p>\n<h2 id=\"34-new-开启和关闭-plugins-since-11015\">34. <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/plugins/PluginSwitch.html\">(new) 开启和关闭 plugins</a> (Since 1.10.15)</h2>\n<p>这是一个测试特性，可以控制一个 mockito-plugin 开启或者关闭。详情请查看 <a href=\"http://site.mockito.org/mockito/docs/current/org/mockito/plugins/PluginSwitch.html\">PluginSwitch</a></p>\n<hr>\n<p><b id=\"34\"></b></p>\n<h3 id=\"35-自定义验证失败信息-since-200\">35. 自定义验证失败信息 (Since 2.0.0)</h3>\n<p>允许声明一个在验证失败时输出的自定义消息\n示例:</p>\n<pre><code class=\"language-java\">// will print a custom message on verification failure\nverify(mock, description(&quot;This will print on failure&quot;)).someMethod();\n\n// will work with any verification mode\nverify(mock, times(2).description(&quot;someMethod should be called twice&quot;)).someMethod();\n</code></pre>\n",
            "image": "https://ct-choochoo.github.io/ch-publii-pages/media/posts/23/Xin-Ming-Zi-98.jpg",
            "author": {
                "name": "铁柱"
            },
            "tags": [
                   "java",
                   "common"
            ],
            "date_published": "2023-03-23T23:50:27+08:00",
            "date_modified": "2023-03-29T00:20:54+08:00"
        }
    ]
}
